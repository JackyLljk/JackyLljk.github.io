[{"title":"二分法","url":"/2023/06/27/algo/bisection/","content":"\n二分的本质：在区间中找到满足某种性质的边界，使得区间二分为“不重叠”的两部分，每次选择答案所在的区间进行下一步处理，当区间长度为1时，即得到查找的答案（或可判断为无解）\n\n有单调性一定可以二分，没有单调性也可以二分（二分本质不是单调性）\n\n\n整数二分的两个模板\n两个模板的区别主要是看 mid 属于左边，还是右边，属于右边时 mid &#x3D; (r + l + 1) &#x2F; 2！\n\n\n\n模板一：mid 属于左区间区间[l, r]被划分成[l, mid]和[mid + 1, r]\nbool check(int x) &#123;/* ... */&#125; // 检查x是否满足某种性质int bsearch_1(int l, int r)&#123;    while (l &lt; r)    &#123;        int mid = l + r &gt;&gt; 1;\t\t// 找中间值 (l+r)/2                // check()判断 mid 是否满足性质        if (check(mid)) \t\t\t            r = mid;    \t// 满足（该情况下左区域包含 mid）        else             l = mid + 1;\t// 不满足（从 mid 下一个位置）    &#125;    return l;\t// 最后 l == r，跳出循环&#125;\n\n\n\n模板二：mid 属于右区间区间[l, r]被划分成[l, mid - 1]和[mid, r]\nbool check(int x) &#123;/* ... */&#125; // 检查x是否满足某种性质int bsearch_2(int l, int r)&#123;    while (l &lt; r)    &#123;        int mid = l + r + 1 &gt;&gt; 1;        // 补 +1，当 l = r-1 时，确保不会死循环（两个模板的主要区分点）                if (check(mid))             l = mid;        else             r = mid - 1;    &#125;    return l;&#125;\n\n\n\n整数二分重要思想\n有序数列，查找 — 选取二分法\n\n\n先写 check() 函数\n根据 check(mid) 判断 mid 的值在左 / 右区间，选取模板\n如果无解，记得满足题意\n\n例题：789. 数的范围\n浮点数二分\n浮点数二分不需要区分边界，每次都是严格取得中间值\n\n\n当最终区间范围足够小时，可认为取得最终答案\n\nbool check(double x) &#123;/* ... */&#125; // 检查x是否满足某种性质double bsearch_3(double l, double r)&#123;    const double eps = 1e-6;    // eps 表示精度，取决于题目对精度的要求    \t\t\t\t\t\t\t// 一般是题目要求的精度下探两位    while (r - l &gt; eps)\t\t\t// 也可以是循环 100 次    &#123;        double mid = (l + r) / 2;        if (check(mid))             r = mid;        else             l = mid;    &#125;    return l;&#125;\n\n\n\n参考模板链接\n","categories":["数据结构与算法"],"tags":["数据结构","算法"]},{"title":"算法技巧：加快读取速度 | 浮点数保留 | 字符串处理","url":"/2023/06/24/algo/algo_skills/","content":"\n选择高效的读入方式 | 浮点数处理 | 字符串处理\n\n\n\n选择高效的读入方式\n经验：当输入比较多时，选择高效的读入方式\n\n1. 选择printf/scanf，而非cout/cin\n当 C++ 读读取大量数据时，使用前者甚至可以提速十倍\n尤其是将cin替换为scanf，读取速度可以显著提高\n\n// printf 输出 用法printf(&quot;字符串&quot;);printf(&quot;格式控制符1 输出控制符2...&quot;，输出参数1，输出参数2,...);// 格式控制符，输出参数的个数一一对应printf(&quot;格式控制符 非输出控制符&quot;, 输出参数);// scanf 输入 用法scanf(&quot;格式控制符&quot;, &amp;输入参数);\t// 不要忘记&quot;&amp;&quot;\t// 变量前有 &amp; 表明“放到以变量的地址为地址的变量中”\n\n2. 优化cout/cin// 在main函数内添加如下代码之一ios::sync_with_stdio(false);\t// code1cin.tie(0);\t// code2\n\n\nJava 用buffread，而非Scanner\n\n浮点数处理经验：保留 k 位小数，精度下探两位\n用法：使用cout输出，保留固定位数的小数\n/* 写法一 */#include &lt;iomanip&gt;\t// 需要使用的头文件cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(6) &lt;&lt; a &lt;&lt; endl;// 输出保留6位小数的变量a/* 写法二 */printf(&quot;%.6lf&quot;, a);\t\t// 更简洁\n\n// 使用scanf输入doublescanf(&quot;%lf&quot;, &amp;a);\t\n\n\n\n字符串处理// substr() 字符串指定长度复制str.substr(pos, len)// 返回值 string，包含str中从pos开始的len个字符的拷贝// pos 的默认值为 0，len 的默认值为 s.size() - pos（默认拷贝整个字符串）\n\n语法题：左旋转字符串\n语法题：把字符串转换成整数\n经验：\n\n字符类型的0对应于 ASCII 码48，获得整数需要-&#39;0&#39;\n字符数组存储的元素是数字的判断语句\n\nstr[k] &gt;= &#39;0&#39; &amp;&amp; str[k] &lt;= &#39;9&#39;\n\n可以用1e11为界限判断int类型是否越界\n当结果可能超出范围时，选取更大的类型，并返回时进行强制转换\n\n其他技巧：输入括号后，再输入右括号，可以直接跳出括号而不使用方向键\n","categories":["数据结构与算法"],"tags":["数据结构","算法"]},{"title":"高精度","url":"/2023/08/15/algo/high_accuracy/","content":"\nC++ 选手需要处理大整数运算\n\nC++ 存储大整数的方式：将每一位存储到数组中，下标0元素对应个位、1元素对应十位…，依次类推（高位存储在数组末端，方便在运算时进行进位操作）\n\n\n常用运算模板\n\nA + B 型（两大整数相加）：（位数）len(A) &lt;=  10^6，len(B) &lt;=  10^6\nA - B 型（两大整数相减）：len(A) &lt;=  10^6，len(B) &lt;=  10^6\nA * b 型（大整数乘小整数）：len(A) &lt;=  10^6，b &lt;= 10^9\nA &#x2F; b 型（大整数除小整数）\n\n从题中读入、输出大整数// 已知输入为两行，分别为大整数 A 和 B#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123;    // 大整数用字符串先读入    string a, b;    vector&lt;int&gt; A, B;        cin &gt;&gt; a &gt;&gt; b;        // 存入 vector（e.g. &quot;123456&quot; -&gt; [6,5,4,3,2,1]）    for(int i = a.size() - 1; i &gt;= 0; i--)        // 存数字，字符要减去偏移量&#x27;0&#x27;        A.push_back(a[i] - &#x27;0&#x27;);    for(int i = b.size() - 1; i &gt;= 0; i--)        B.push_back(b[i] - &#x27;0&#x27;);        // 进行操作    auto C = func(A, B);        // 读入和输出都是从最高位开始    for(int i = C.size() - 1; i &gt;= 0; i--)        printf(&quot;%d&quot;, C[i]);        return 0;&#125;\n\n\n\n\n\nA + B 型Ci = (Ai + Bi + ti)%10, ti = (Ai-1 + Bi-1)/10\n// C = A + B, A &gt;= 0, B &gt;= 0vector&lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123;    if(A.size() &lt; B.size())\treturn add(B, A);        vector&lt;int&gt; C;    int t = 0;    for(int i = 0; i &lt; A.size(); i++)    &#123;        // 加上进位，如果有B[i]也加上        t += A[i];        if(i &lt; B.size()) t += B[i];                // 取余为i位的值，保存进位t        C.push_back(t % 10);        t /= 10;    &#125;        if(t) C.push_back(t);        return C;&#125;\n\n例题：791.高精度加法\nA - B 型\n先判断 A 和 B 的大小，选择运算次序\n\n// 判断 A &gt;= B bool cmp(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123;    if(A.size() != B.size()) return A.size() &gt; B.size();        for(int i = A.size() - 1; i &gt;= 0; i--)        if(A[i] != B[i])            return A[i] &gt; B[i];   \treturn true;\t// 包含A == B的情况&#125;// C = A - B, A &gt;= B, A &gt;= 0, B &gt;= 0vector&lt;int&gt; sub(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123;    vector&lt;int&gt; C;        // 已保证 A &gt;= B    for(int i = 0, t = 0; i &lt; A.size(); i++)    &#123;        // 减去上一位借位        t = A[i] - t;                // 判断 B 是否有这一位        if(i &lt; B.size())             t -= B[i];                // 精妙处理！：综合处理两种情况：1. t&gt;=0, 即t；2. t&lt;0, 借一位        C.push_back((t + 10) % 10);                // 判断是否需要借一位        if(t &lt; 0) t = 1;        else t = 0;    &#125;        // 去掉高位存在的0    while(C.size() &gt; 1 &amp;&amp; C.back() == 0)        C.pop_back();        return C;&#125;\n\n例题：792. 高精度减法\nA * b 型// C = A * b, A &gt;= 0, b &gt;= 0vector&lt;int&gt; mul(vector&lt;int&gt; &amp;A, int b)&#123;    vector&lt;int&gt; C;        int t = 0;        // &quot;||t&quot; 条件表示进位 t 还没处理完    for(int i = 0; i &lt; A.size() || t; i++)    &#123;        if(i &lt; A.size()) \t\t\t// 如果A还没处理完：t = 上一位的进位 + A[i]*b            t += A[i] * b;                // 每次只考虑取余得到的个位和进位（下一位的个位）        C.push_back(t % 10);        t /= 10;    &#125;        // 去掉高位存在的0    while(C.size() &gt; 1 &amp;&amp; C.back() == 0)        C.pop_back();        return C;&#125;\n\n例题：793. 高精度乘法\nA &#x2F; b 型// C = A / b 余 r, A &gt;= 0, b &gt; 0// 余数 r 用的是实参（答案可能要用到）vector&lt;int&gt; div(vector&lt;int&gt; &amp;A, int b, int &amp;r)&#123;    vecotr&lt;int&gt; C;    r = 0;        for(int i = A.size() - 1; i &gt;= 0; i--)    &#123;        // 按照除法的逻辑：上一位的余数补在A[i]的左边一位        r = r * 10 + A[i];                // 保存当前位，以及余数 r        C.push_back(r / b);        r %= b;    &#125;        // C的开头存储的是数字的高位，需要调转    reverse(C.begin(), C.end());        // 删掉高位的0    while(C.size() &gt; 1 &amp;&amp; C.back() == 0)        C.pop_back();    return C;&#125;\n\n例题：794. 高精度除法\n参考算法基础课模板\n算法基础课\n","categories":["数据结构与算法"],"tags":["数据结构","算法"]},{"title":"KMP字符串匹配","url":"/2023/08/05/algo/kmp/","content":"\nKMP 是由 Knuth，Morris，Pratt 三人设计的线性时间字符串匹配算法\n\n\n\n题目链接：831.KMP字符串\n暴力解法for(int i = 1; i &lt;= n; i++)&#123;  bool flag = true; \tfor(int j = 1; j &lt;= m; j++)  &#123;    if(s[i+j-1] != p[j])    &#123;      flag = false;      break;    &#125;  &#125;&#125;\n\n\n\n使用 KMP 优化用到的概念s[]：模式串，即被匹配的字符串\np[]：模板串，用模板串去匹配模式串\n前缀：非平凡前缀，指除了最后一个字符外，一个字符串的全部头部组合\n后缀：非平凡后缀，指除了第一个字符外，一个字符串的全部尾部组合\n部分匹配值值：前缀和后缀的最长共有元素的长度\nnext[]数组：部分匹配值表，存储每一个下标对应的部分匹配值\nnext[] 数组详解next[]数组是由对模板串（简称p串）预处理得到\n\nnext[j]表示p[1,j]的部分匹配值（p[1,j]串中前缀和后缀相同字符的最大长度）\n\nnext[j] = i，即p[1,i] = p[j - i + 1, j]\n\n\n​\t\n求 next[] 数组过程：通过模板串自己与自己进行匹配得到（匹配过程类似KMP匹配）\nfor(int i = 2, j = 0; i &lt;= n; i++)\t// 根据后缀定义，从第二个字符开始匹配&#123;  \twhile(j &amp;&amp; p[i] != p[j + 1])\tj = ne[j];    \tif(p[i] == p[j+1])\tj++;\t// 下一个位置匹配成功，移动    \tne[i] = j;\t// 当前长度的字符串匹配成功，记录已经匹配的长度（即前缀长度 = 后缀长度 = j）&#125;\n\n\n\n\n\nKMP匹配过程这里 s串和 p串都是从下标1开始\n​\t\n匹配过程如上图所示：\n\n当s[a,b]与p[1,j]匹配，但下一个位置s[i] != p[j+1]时，要移动 p串\n区别于暴力解法，p 串并非向后移动1位，而是直接移动到下次能匹配该部分的位置（② 对应 ①）\n这种移动操作可由j = next[j]完成\n\n// KMP 匹配过程for(int i = 1, j = 0; i &lt;= m; i++)&#123;\t\twhile(j &amp;&amp; s[i] != p[j + 1]) j = ne[j];  \t// 1. j != 0 表示j没有退回起点，并非从头开始匹配  \t// 2. s[i] != p[j+1] 说明当前位置的下一个字符并不匹配  \t// j = ne[j] 调用next[j]，将模板串后移到后缀位置    \tif(s[i] == p[j + 1]) j++;  \t// 下一个位置匹配成功   \t \tif(j == n)\t// 整个模板串匹配成功 \t\t&#123;   \t printf(&quot;%d &quot;, i - n);\t// 匹配成功   \t j = ne[j];\t\t// 继续匹配下一个位置 \t \t&#125;&#125;\n\n\n\n完整代码#include &lt;iostream&gt;using namespace std;const int N = 1e5 + 10, M = 1e6 + 10;int n, m;char p[N], s[M];int ne[N];  // next数组（以防当作保留字报错）int main()&#123;    cin &gt;&gt; n &gt;&gt; p + 1 &gt;&gt; m &gt;&gt; s + 1;\t// &quot;+1&quot;表示下标从1开始        // 求next数组过程    for(int i = 2, j = 0; i &lt;= n; i++)    &#123;        while(j &amp;&amp; p[i] != p[j + 1]) j = ne[j];        if(p[i] == p[j + 1]) j++;        ne[i] = j;    &#125;        // kmp匹配过程     for(int i = 1, j = 0; i &lt;= m; i++)     &#123;         while(j &amp;&amp; s[i] != p[j + 1]) j = ne[j];         if(s[i] == p[j + 1]) j++;         if(j == n)         &#123;             printf(&quot;%d &quot;, i - n);             j = ne[j];              &#125;     &#125;     return 0;&#125;\n\n时间复杂度： O(N)\n参考\n题解：KMP 字符串\nacwing 算法基础课（数据结构 (一) ）\n\n","categories":["数据结构与算法"],"tags":["数据结构","算法"]},{"title":"前缀和 | 差分","url":"/2023/08/20/algo/prefix_sum_and_difference/","content":"前缀和一维前缀和\n用法：快速求原数组中的一段数的和，时间复杂度：O(1)（不需要使用循环 O(N)）\n\n\n\n一维前缀和定义：\n原数组：a1, a2, a3, ..., an（数组下标从1开始！）\n前缀和数组：S1, S2, S3, ..., Sn，其中Si = a1 + a2 + ... + ai（下标也是从1开始，定义S0 = 0）\n求 Si\nfor(int i = 1; i &lt;= n; i++)\tSi = Si-1 + ai;\n求[l, r]这一段数的和：sum = Sr - Sl-1\t\t\n\n消除边界情况的差异，一般使前缀和从 1 开始，而数组也从下标 1 开始\n\n// 前缀和的应用: 求数组 a 中从 l 到 r 的和int a[N];int s[N];// 数组 s 和 a 都是从下标 1 开始存放元素，即 1~n 存放元素for(int i = 1; i &lt;= n; i++)\t    s[i] - s[i-1] = a[i];\t// 前缀和初始化sum = s[r] - s[l-1];\t\t// 区间和的计算\n\n二维前缀和​\t\n求 $S_&#123;ij&#125;\n​\t（方框内的点表示元素）\nfor(int i = 1; i &lt; n; i++)    for(int j = 1; j &lt; m; j++)        s[i][j] = s[i-1][j] - s[i][j-1] + a[i][j]\n\n用法：快速求出区域矩阵内的元素和\n求和：即整个区域减去两个矩形区域，再补上重复减去的区域\nsum = s[x2][y2] - s[x2][y1-1] - s[x1-1][y2] + s[x1-1][y1-1]\n题目理解：子矩阵的和（模板）\n输入一个 n 行 m 列的整数矩阵，再输入四个整数 x1, y1, x2, y2，表示一个子矩阵的左上角左边和右下角坐标，输出子矩阵所有数的和。\n输入：n, m;\n​\t\t\t接下来 n 行，每行包含 m 个整数，表示整数矩阵\n​\t\t\t输入一行，包含四个整数 x1, y1, x2, y2\n输出：子矩阵所有数的和\n#include &lt;iostream&gt;using namespace std;const int N = 1001;int a[N][N], s[N][N];int n, m;int main(void)&#123;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;        //\t接收数组的同时，得到二维前缀和    for(int i = 1; i &lt;= n; i++)&#123;        for(int j = 1; j &lt;= m; j++)&#123;            scanf(&quot;%d&quot;, &amp;a[i][j]);            s[i][j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1] + a[i][j];        &#125;    &#125;          int x1, y1, x2, y2, sum;     cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;            // 二维前缀和求子矩阵，模板    sum = s[x2][y2] - s[x1-1][y2] - s[x2][y1-1] + s[x1-1][y1-1];            cout &lt;&lt; sum &lt;&lt; endl;    return 0;&#125;\n\n\n\n差分\n差分是前缀和的逆运算\n\n一维差分差分定义：\n\n原数组：a1, a2, a3, ..., an\n\n构造：b1, b2, b3, ..., bn\n\n使得：ai = b1 + b2 + b3 + ... + bi\n\n\n则 a 是 b 的前缀和，b 是 a 的差分\n用法：给区间[l, r]中的每个数加上c，求加后序列\n\n使得时间复杂度 **$O(1)$**（无需遍历）\n\n\t\n\n\n综上，即只需修改b[l]和b[r + 1 ]即可求和-\n\n理解: 初始数组可以看作是在区间[1,1]插入a[i];\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t[2,2]插入a[2]以此类推到[n,n]插入a[n]\n\n即差分只需要一种插入操作\n\n// 模板：给数组指定区间内的每个元素加上常数,求加上后的序列#include &lt;iostream&gt;using namespace std;const int N = 100010;int n;int a[N], b[N];// 差分的插入操作void insert(int l, int r, int c)&#123;    b[l] += c;\t\t    b[r + 1] -= c;&#125;int main(void)&#123;    cin &gt;&gt; n;    for(int i = 1; i &lt;= n; i++)        scanf(&quot;%d&quot;, &amp;a[i]);        // 根据上文理解，得到差分序列 b1, b2,..., bn    for(int i = 1; i &lt;= n; i++)        insert(i, i, a[i]);        int l, r, c;\t\t// 取得区间的左右边界、常数    cin &gt;&gt; l &gt;&gt; r &gt;&gt; c;    insert(l, r, c);\t// 进行插入操作        // 即将 bi 变换成自己的前缀和，对应插入常数后的 ai    for(int i = 1; i &lt;= n; i++)        b[i] += b[i - 1];        for(int i = 1; i &lt;= n; i++)        cout &lt;&lt; b[i] &lt;&lt; &quot; &quot;;        return 0;&#125;\n\n二维差分 逆向二维前缀和，原矩阵a[i][j]，差分矩阵b[i][j]，原矩阵是差分矩阵的前缀和\n用法：给子矩阵的每个元素加上常数 c，输出子矩阵（时间复杂度达到 **$O(1)$**）\n\n\n题目理解：798.  差分矩阵\n// 核心代码int a[N][N];int b[N][N];\t// 差分矩阵\n\n\n\n","categories":["数据结构与算法"],"tags":["数据结构","算法"]},{"title":"快速排序 | 归并排序","url":"/2023/06/24/algo/sort/","content":"\n分治算法基本三部：1. 分成子问题；2. 递归处理子问题；3. 子问题合并\n\n快速排序和归并排序都是基于分治的思想\n\n\n快速排序算法思想\n基于分治的思想：\n\n\n确定分界点：左边界q[l]，中间值q[(l+r)/2]，右边界q[r]，也可以随机\n调整区间：通过 x 的值，划分区间（x 左边≤x，右边≥x）△\n递归：递归处理左、右区间\n\n\n\n// 快排模板void quick_sort(int q[], int l, int r)&#123;    if(l &gt;= r) return;\t   \t    int i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1];    while(i &lt; j)    &#123;        do i++; while(q[i] &lt; x);        do j--; while(q[j] &gt; x);        if(i &lt; j) swap(q[i], q[j]);\t    &#125;    quick_sort(q,l,j);    quick_sort(q,j+1,r);&#125;// 参考：https://www.acwing.com/activity/content/code/content/39784/\n\n细节剖析// 快排模板void quick_sort(int q[], int l, int r)&#123;    // 判断边界，只有一个数/没有数则直接返回，也可以写作 ”l == r“    if(l &gt;= r) return;\t   \t    // 分成子问题    int i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1];    while(i &lt; j)    &#123;        do i++; while(q[i] &lt; x);        do j--; while(q[j] &gt; x);        if(i &lt; j) swap(q[i], q[j]);\t// swap,交换两个数    &#125;        // 递归处理子问题    quick_sort(q, l, j);    quick_sort(q, j+1, r);        // 子问题合并（此处不需要）&#125;\n\n语法补充\nl + r &gt;&gt; 1\t当左侧为非负数时，相当于 (l + r) &#x2F; 2（为负奇数时，会有区别）\ndo i++; while(q[i] &lt; x); 就是一个 do-while 循环\ndo&#123;    i++;&#125;while(q[i] &lt; x);    // 等价写法\n\n思路理解\n\n确定枢轴 x（这里选择的是数组中间的值）\n设置两个指针i, j，分别从数组两侧向中间移动\n利用循环，使得q[l...i] &lt;= x 且 q[j...r] &gt;= x\n递归排列左右两部分\n\n子问题理解\nint i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1];// 由于后面使用的是 do-while 循环，先增减再操作，需要确保从左右端开始\n\n使用 do-while：保证先递增，使得循环可以继续进行\n使用 while 可能会死循环（例：q[i] 和 q[j] 都等于 x 时，i j 不会更新，外层 while 循环卡死）\ndo i++; while(q[i] &lt; x);\t// 使 q[l...i-1] &lt;= x，q[i] &gt;= x     do j--; while(q[j] &gt; x);// 使 q[j+1...r] &gt;= x，q[j] &lt;= x     if(i &lt; j) swap(q[i], q[j]);\t// 交换，使得 q[l...i] &lt;= x，q[j...r] &gt;= x/* 边界问题：如果上述 do-while 循环的条件为 ≥ 或 ≤ \t\t假设数组 q[l...r] 内元素全相等，\t \t则语句 do i++; while(q[i] &lt;= x); 会执行到 r + 1\t \t然后执行 a[i] &lt;= x 也成立，则会一直循环下去；\t \t最终报错：Meomory Limit Exceeded. */\n\n如何得到递减序列？while(i &lt; j)&#123;    do i++; while(q[i] &gt; x);\t    // 此处比较运算符更改一下，循环结果取得 q[i] &lt;= x    do j--; while(q[j] &lt; x);    if(i &lt; j) swap(q[i], q[j]);\t&#125;\n\n参考：acwing 算法基础课\n例题：785. 快速排序\n归并排序算法思想\n基于分治的思想\n\n\n确定分界点，取数组下标中间值\n\n递归排序 left，right\n\n归并，合二为一 △（O(N)）\n\n\n// 归并模板void merge_sort(int q[], int l, int r)&#123;    if (l &gt;= r) return;    int mid = l + r &gt;&gt; 1;\t    merge_sort(q, l, mid);    merge_sort(q, mid + 1, r);    int k = 0, i = l, j = mid + 1;    while (i &lt;= mid &amp;&amp; j &lt;= r)        if (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];        else tmp[k ++ ] = q[j ++ ];    while (i &lt;= mid) tmp[k ++ ] = q[i ++ ];    while (j &lt;= r) tmp[k ++ ] = q[j ++ ];    for (i = l, j = 0; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];&#125;// 参考：https://www.acwing.com/blog/content/277/\n\n细节理解void merge_sort(int q[], int l, int r)&#123;    if (l &gt;= r) return;    // 分治第一步：分成子问题    int mid = l + r &gt;&gt; 1;\t/// 划分，取得区间中点            // 第二步：递归处理子问题    merge_sort(q, l, mid);\t// 递归排序左右区间    merge_sort(q, mid + 1, r);    // 第三步：合并子问题    int k = 0, i = l, j = mid + 1;   \t// i 指向左半边起点，j 指向右半边起点        while (i &lt;= mid &amp;&amp; j &lt;= r)\t// 当左右区间都没有循环为空时        // 取小的存入数组        if (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];\t        else tmp[k ++ ] = q[j ++ ];    // 把剩余没有为空的半边的数接入数组    while (i &lt;= mid) tmp[k ++ ] = q[i ++ ];    while (j &lt;= r) tmp[k ++ ] = q[j ++ ];    // 将临时数组的序列存回 q 数组中    for (i = l, j = 0; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];&#125;\n\nfor (i = l, j = 0; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];\n使用两个控制变量？根据前面定义的int k = 0；，在每次递归中，临时数组都是从下标0位置开始存放数据，而对于数组q，在递归中需要排序的范围是l-r，所以这里需要两个控制变量来转存\n// 使用一个控制变量的写法void mergeSort(int q[], int l, int r)&#123;    if(l &gt;= r)  return;        int mid = l + r &gt;&gt; 1;        mergeSort(q, l, mid);    mergeSort(q, mid + 1, r);    // 区别1：在每次递归中，都从临时数组的 &quot;l&quot; 位置开始存放数据    int i = l, j = mid + 1, k = l;      while(i &lt;= mid &amp;&amp; j &lt;= r)&#123;        if(q[i] &lt;= q[j])\ttemp[k++] = q[i++];        else\ttemp[k++] = q[j++];    &#125;    while(i &lt;= mid)\ttemp[k++] = q[i++];    while(j &lt;= r)\ttemp[k++] = q[j++];        // 区别2：这样针对递归中的每个 q[l...r]，    // 都可以有对应的 temp[l...r]，只用一个控制变量    for(i = l; i &lt;= r; i++) q[i] = temp[i];     &#125;\n\n\n\n参考课程：acwing 算法基础课\n例题：787. 归并排序\t788. 逆序对的数量\n","categories":["数据结构与算法"],"tags":["数据结构","算法"]},{"title":"寻找目标","url":"/2023/06/23/life/new_beginning/","content":"叹当下：昨夜西风凋碧树，独上高楼，望尽天涯路。\n愿未来：衣带渐宽终不悔，为伊消得人憔悴。\n","categories":["生活"],"tags":["经历"]},{"title":"Hexo 常用操作","url":"/2022/01/23/tech/hexo_operation/","content":"\nHexo 常用命令 | 文章变量设置\n\n\n\n主题使用使用 keep 主题\n主题更新 &#x2F; 样式设置\nPicX 图床\n常用命令hexo new [postName]\t\t# 在 source/_posts 下新建文章hexo new page [pageName]\t\t# 在 source/pageName 下新建页面hexo d\t\t# 将 .deploy 目录部署到 GitHubhexo g\t\t# 生成静态页面至 public 目录hexo s\t\t# 开启预览访问端口（默认 port：4000），ctrl + c 关闭 serverhexo clean\t\t# 清除所有静态页面和缓存数据\n\n\n\nFront-matter# 文章变量设置示例（置于_posts下文章最上方）---title:\t文章标题\t\tdate: 2020-01-21 12:00:00tags:\t[tag1, tag2]categories: [文章分类]&#123;sricky:\t权重值&#125;\t\t# 文章置顶位置&#123;toc:\tfalse&#125;\t\t# 关闭文章目录---# 文章截取符&lt;!--more--&gt;\n","categories":["技术"],"tags":["Hexo"]},{"title":"Go 基础学习","url":"/2023/11/27/language/basic_go/","content":"\nGolang 启动!!!!!\n\n参考博客：Go语言学习之路&#x2F;Go语言教程\n\n\n知识点大纲&#x2F;要点变量和常量\n变量声明方式：标准声明，批量声明\n初始化（可以一次初始化&#x2F;赋值多个变量，a, b = 4, 3.1415926）\n类型推导\n短变量声明（:=，只能在函数内使用）【常用】\n匿名变量（_）\n常量（const，通常定义在全局）\niota常量计数器（跳过、插队、定义数量级、多个iota）\n\n基本数据类型\n整型：有符号、无符号，特殊整型（不使用的情况） \n数字字面量：十进制、八进制（0开头，%o）、十六进制（0x开头，%x），二进制（十进制打印为二进制%b)\n浮点数：float32，float64（%f，%.2f）\n布尔值：默认false，不允许从整型强制转换，无法参与数值运算\n字符串：原生数据类型，&quot;&quot;内\n字符串转义符\n多行字符串&#39;&#39;内\n修改字符串\n常用操作：len(str)，拼接+，分隔，str.contains，前后缀判断，子串位置（第一个下标），join操作\n\n\n复数\n字符byte, rune：&#39;&#39;内，%c\n强制类型转换：T()\n\nfmt\n输出：\n\nPrint，Printf，Println\n\n写入文件：Fprint\n\n返回字符串：Sprint\n\nEprint\n\n\n\n格式化占位符\n\n输入：\n\nScan，Scanf，Scanln\nbufio.NewReader\nFscan\nSscan\n\n\n\n运算符\n类似 C++\n--，++是单独的一行语句\n\n流程控制\nif 条件判断：特殊写法（局部变量声明 + 判断）\nfor 循环（省略初始和结束语句（类似while），无限循环）\nfor range键值循环\nswitch case\ncontinue，break\ngoto\n\n数组var a [元素数量]T\t// T：数据类型，数组大小不可变，不同元素数量的数组是不同的类型\n\n\n数组初始化：\n\n初始化列表[2]string&#123;&quot;abc&quot;, &quot;bcd&quot;&#125;\n编译器推测长度[...]bool&#123;&#125;\n索引值方式a := [...]int&#123;1: 1, 3: 5&#125;\n\n\n遍历数组：len(array)得到数组的长度\n\nfor 循环遍历\nfor range 循环遍历\n\n\n二维数组及其遍历\n\n\n\n多维数组只有第一层可以使用...让编译器推测数组长度，内部的&#123;&#125;以,为结尾\n\n\n数组是值类型：赋值和传参会拷贝数组，改变副本不影响本身\n\n切片\n切片是引用类型，基于数组做的一层封装，内部结构包含地址、长度size、容量cap\n\n切片定义方式：\n切片初始化后才能使用！\n\n\nvar a []T\n\n基于数组得到切片：对切片再次切片：s := a[low:high]（简单切片表达式，完整切片表达式a[low, high, max]）\n\n\ncap = max - low；low可以缺省为 0\na := [5]int&#123;1, 2, 3, 4, 5&#125;s := a[1:4]\t\t// &#123;2, 3, 4&#125;：左包含，右不包含s1 := a[:]\t\t// 从头切到尾s2 := s[1:2]\t// &#123;3&#125;// 对切片再次切片时，high的上限变成被切切片的容量\n\n\nmake 函数构造：s := make([]T, size, cap)\n\n切片的使用\nlen()获得切片长度，cap()获得切片容量\n\n切片的本质\n\n切片不能直接比较：s == nil表示切片没有底层数组\n\n\n// 同样长度、容量为0的切片var s1 []int\t// s1 == nil，没有申请内存，需要初始化var s2 []int&#123;&#125;\t// s2 != nil，已经初始化\n\n\n判空：len(s)==0\n\n切片的赋值拷贝：切片赋值给切片后，二者公用一个底层数组\n\n遍历切片（同数组）\n\n\n切片的其他操作\n动态添加元素：s = append(s, 元素1, 元素2)，底层数组容量不够时可以自动扩容（重新申请更大的一块内存）\n\n可以追加切片：s1 = append(s1, s2...)\n\n! 扩容前后的内存地址是不同的\n\n\n切片的扩容策略\n\n使用copy()复制切片：copy(s2, s1)，s2 使用另一个切片空间\n\n从切片中删除元素：s = append(s[:index], s[index+1:]...)\n\n\nmap\nmap 是无序的基于key-value的数据结构，是引用类型，初始化后才能使用\n\n\n定义map：map[keyType]valueType\n\n默认初始值为nil，make(map[keyType]valueType, [cap])分配内存\n\n\n\n\n要点记录\n单行注释、多行注释（同 C++）\n\n花括号不能单独另起一行；语句末不需要分号\n\n可在全局声明和初始化变量，但不能单独赋值\n\ngo fmt可以自动格式化代码，使风格统一，会自动调用\n\n使用驼峰命名法\n\n\n问题记录&#x2F;待补充\nother declaration of main：在 Go 中，一个目录（文件夹）就是一个包，一个包只能有一个给定名称的函数（除了init()），不能在同一目录下出现多个同名函数\n\n\n\n","categories":["编程语言"],"tags":["编程语言","Go"]}]