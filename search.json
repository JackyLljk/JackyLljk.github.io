[{"title":"二分法","url":"/2023/06/27/algo/bisection/","content":"\n二分的本质：在区间中找到满足某种性质的边界，使得区间二分为“不重叠”的两部分，每次选择答案所在的区间进行下一步处理，当区间长度为1时，即得到查找的答案（或可判断为无解）\n\n有单调性一定可以二分，没有单调性也可以二分（二分本质不是单调性）\n\n\n整数二分的两个模板\n两个模板的区别主要是看 mid 属于左边，还是右边，属于右边时 mid &#x3D; (r + l + 1) &#x2F; 2！\n\n\n\n模板一：mid 属于左区间区间[l, r]被划分成[l, mid]和[mid + 1, r]\nbool check(int x) &#123;/* ... */&#125; // 检查x是否满足某种性质int bsearch_1(int l, int r)&#123;    while (l &lt; r)    &#123;        int mid = l + r &gt;&gt; 1;\t\t// 找中间值 (l+r)/2                // check()判断 mid 是否满足性质        if (check(mid)) \t\t\t            r = mid;    \t// 满足（该情况下左区域包含 mid）        else             l = mid + 1;\t// 不满足（从 mid 下一个位置）    &#125;    return l;\t// 最后 l == r，跳出循环&#125;\n\n\n\n模板二：mid 属于右区间区间[l, r]被划分成[l, mid - 1]和[mid, r]\nbool check(int x) &#123;/* ... */&#125; // 检查x是否满足某种性质int bsearch_2(int l, int r)&#123;    while (l &lt; r)    &#123;        int mid = l + r + 1 &gt;&gt; 1;        // 补 +1，当 l = r-1 时，确保不会死循环（两个模板的主要区分点）                if (check(mid))             l = mid;        else             r = mid - 1;    &#125;    return l;&#125;\n\n\n\n整数二分重要思想\n有序数列，查找 — 选取二分法\n\n\n先写 check() 函数\n根据 check(mid) 判断 mid 的值在左 / 右区间，选取模板\n如果无解，记得满足题意\n\n例题：789. 数的范围\n浮点数二分\n浮点数二分不需要区分边界，每次都是严格取得中间值\n\n\n当最终区间范围足够小时，可认为取得最终答案\n\nbool check(double x) &#123;/* ... */&#125; // 检查x是否满足某种性质double bsearch_3(double l, double r)&#123;    const double eps = 1e-6;    // eps 表示精度，取决于题目对精度的要求    \t\t\t\t\t\t\t// 一般是题目要求的精度下探两位    while (r - l &gt; eps)\t\t\t// 也可以是循环 100 次    &#123;        double mid = (l + r) / 2;        if (check(mid))             r = mid;        else             l = mid;    &#125;    return l;&#125;\n\n\n\n参考模板链接\n","categories":["数据结构与算法"],"tags":["数据结构","算法"]},{"title":"位运算","url":"/2023/11/01/algo/bitwise_operation/","content":"两个问题与一个补充\n\nx 的二进制表示中第 k 位是多少\n统计 x 二进制表示中 1 的个数\n原码、补码、反码\n\n\n\n模板模板1：n 的二进制表示中第 k 位是几\n从个位起，个位为第 0 位\n\n\n先把第 k 位移到最后一位（右移 k）\n看个位是几（与 1）\n\ncout &lt;&lt; (n &gt;&gt; k &amp; 1);\n\n\n\n模板2：lowbit(x)，统计x中1的个数lowbit(x)：返回 x 的最后一位 1 之后的二进制数（二进制，即最右边）\n\n例如：x &#x3D; 10100，lowbit(x) &#x3D; 100\n\n// 整数的负数是补码（~x+1 取反加一）// -x = ~x+1int lowbit(int x)&#123;    return x &amp; -x;&#125;// 从最低位开始循环消除最后一位1，同时统计消除的次数，即得到二进制x中1的个数x -= lowbit(x);\n\n例题：801. 二进制中1的个数\n知识点补充：原码、反码、补码原码：0...01010\n反码：1...10101\n补码：1...10110（~x+1）\n一种解释x + (-x) = 0-x = 0 - x   = 0...0 - x   = 10...0 - x（从更高位借1）   = ~x + 1\n\n","categories":["数据结构与算法"],"tags":["数据结构","算法"]},{"title":"面向算法的 Cpp 用法","url":"/2023/12/22/algo/cpp_for_algo/","content":"\n求解算法题需要用到的那些 Cpp 语法\n\n\n\n选择高效的读入方式\n经验：当输入比较多时，选择高效的读入方式\n\n选择printf/scanf，而非cout/cin\n当 C++ 读读取大量数据时，使用前者甚至可以提速十倍\n尤其是将cin替换为scanf，读取速度可以显著提高\n\n// printf 输出 用法printf(&quot;字符串&quot;);printf(&quot;格式控制符1 输出控制符2...&quot;，输出参数1，输出参数2,...);// 格式控制符，输出参数的个数一一对应printf(&quot;格式控制符 非输出控制符&quot;, 输出参数);// scanf 输入 用法scanf(&quot;格式控制符&quot;, &amp;输入参数);\t// 不要忘记&quot;&amp;&quot;\t// 变量前有 &amp; 表明“放到以变量的地址为地址的变量中”\n\n优化cout/cin// 在main函数内添加如下代码之一ios::sync_with_stdio(false);\t// code1cin.tie(0);\t// code2\n\n\n\n浮点数处理经验：保留 k 位小数，精度下探两位\n用法：使用cout输出，保留固定位数的小数\n/* 写法一 */#include &lt;iomanip&gt;\t// 需要使用的头文件cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(6) &lt;&lt; a &lt;&lt; endl;// 输出保留6位小数的变量a/* 写法二 */printf(&quot;%.6lf&quot;, a);\t\t// 更简洁\n\n// 使用scanf输入doublescanf(&quot;%lf&quot;, &amp;a);\t\n\n\n\n字符串处理// substr() 字符串指定长度复制str.substr(pos, len)// 返回值 string，包含str中从pos开始的len个字符的拷贝// pos 的默认值为 0，len 的默认值为 s.size() - pos（默认拷贝整个字符串）\n\n语法题：左旋转字符串\n语法题：把字符串转换成整数\n经验：\n\n字符类型的0对应于 ASCII 码48，获得整数需要-&#39;0&#39;\n字符数组存储的元素是数字的判断语句\n\nstr[k] &gt;= &#39;0&#39; &amp;&amp; str[k] &lt;= &#39;9&#39;\n\n可以用1e11为界限判断int类型是否越界\n当结果可能超出范围时，选取更大的类型，并返回时进行强制转换\n\n常用数据类型vector\nvector 类似数组，但可以动态扩展（找更大的内存空间，将原数组拷贝，释放原空间）\n\n// 用法#include &lt;vector&gt;\t// 头文件vector&lt;T&gt; v;\t// 模板实现v.empty();\t\t// 判空v.size();\t\t// 返回元素个数v.push_back(elem);\t\t// 尾部插入元素 elemv.pop_back();\t\t\t// 删除最后一个元素v.clear();\t\t\t\t// 清空// 可以用”[] + 下标“操纵容器v.front();\t// 返回容器第一个元素v.back();\t// 返回容器最后一个元素\n\n使用技巧\n\n在创建 vector 时如果没有指定长度，则 vector 中不存在任何元素，无法被读取\n仅当 vector 某位置已经存在元素时，才可以使用下标进行操作\n使用v.size()获取大小时，返回的类型为unsigned int\n\n理解 resize() 和 reserve()\nhttps://blog.csdn.net/liuweiyuxiang/article/details/88692708\npair// 将两个数据组成一组数据pair&lt;T1, T2&gt; p;p.first;\t// 返回第一个值p.second;typedef pair&lt;T1, T2&gt; PII;\t// 简化声明\n\n\n使用sort()进行排序时，首先以左端点进行排序，仍然相同的话再以右端点进行排序\n\n常用辅助函数#include &lt;algorithm&gt;\t// 算法头文件std::max(a, b);\t\t\t// 返回参数 a 和 b 的最大值std::min(a, b);\t\t\t// 返回参数 a 和 b 的最小值std::swap(a, b);\t\t// 交换参数 a 和 b 的值\n\n#include &lt;cmath&gt;\t// 头文件pow(4, 2);\t\t// 4 的平方sqrt(4);\t\t// 4 开方abs(b-a);\t\t// 绝对值reverse(first, last);\t// 反转 [first，last) 范围内元素的顺序vector&lt;int&gt; v = &#123;5,4,3,2,1&#125;;reverse(v.begin(), v.end());\t// v = &#123;1,2,3,4,5&#125;string str = &quot;www.mathor.top&quot;;reverse(str.begin(), str.end());\t// str = &quot;pot.rohtam.wwww&quot;// begin(), end() 函数，可用于 string，vector,...v.begin();\t// 返回指向首个元素的指针v.end();\t// 返回指向最后一个元素“之后位置”的指针\n\n","categories":["数据结构与算法"],"tags":["数据结构","算法","编程语言","C++"]},{"title":"离散化 | 区间和并","url":"/2023/11/01/algo/discretization_and_margin/","content":"\n离散化：当值域跨度大，但值分布稀疏时，将用到的值的坐标映射到较小空间内使用\n区间和并：快速合并所有有交集的区间\n\n\n\n离散化离散化：当值域跨度大，但值分布稀疏时，将用到的值的坐标映射到较小空间内使用，这样只需对映射后的数据结构进行操作即可节省空间开销（把无限空间中的有限个体映射到有限的空间中去）\n基本步骤\n存储操作需要数据的坐标到数组a\n对数组进行去重\n通过原坐标值找到现在的坐标，并进行操作（二分）\n\n数组去重// “排序 + 去重”// 存储所有待离散化的值vector&lt;int&gt; alls;// 将所有值排序sort(alls.begin(), alls.end());// 去掉重复元素alls.erase(unique(alls.begin(), alls.end()), alls(end));// unique(begin, end): 将有序数组去重，将重复元素放在容器末端，返回去重后的尾端点// erase(begin, end): 删掉数组中的元素（删掉尾端点之后的重复元素）\n\n补充：unique()实现逻辑采用双指针算法，找出有序数组中所有满足以下条件之一：\n\n该数是第一个数\na[i] != a[i-1]\n\n即是要找的不同的数\nvector&lt;int&gt;::iterator unique(vector&lt;int&gt; &amp;a)&#123;    int j = 0;    for(int i = 0; i &lt; a.size(); i++)    \tif(!i || a[i] != a[i-1])            // 满足条件后，记录在数组前部分，同时移动指针j            a[j++] = a[i];        return a.begin() + j; &#125;\n\n\n\n题型示例例题1：802. 区间和\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;// n次插入，2m次查询(l,m)，数量级都是10^5const int N = 3e5 + 10;// 存放数据对(1.坐标、c；2.查询区间)typedef pair&lt;int, int&gt; PII;int n, m;// 存放坐标插入的值，和其前缀和数组int a[N], s[N];// 存储所有被访问到的坐标(离散化的值)vector&lt;int&gt; alls;// 存储插入和查询操作的数据vector&lt;PII&gt; add, query;// 将坐标x映射为离散化下标(求x离散化之后的结果)int find(int x)&#123;    int l = 0, r = alls.size() - 1;    while(l &lt; r)    &#123;        int mid = l + r &gt;&gt; 1;        if(alls[mid] &gt;= x)               r = mid;        else             l = mid + 1;    &#125;    return r + 1;&#125; int main()&#123;    cin &gt;&gt; n &gt;&gt; m;        for(int i = 0; i &lt; n; i++)    &#123;        int x, c;        cin &gt;&gt; x &gt;&gt; c;        add.push_back(&#123;x, c&#125;);  // 存放插入操作的数据对        alls.push_back(x);      // 存放插入用的的下标x    &#125;        for(int i = 0; i &lt; m; i++)    &#123;        int l, r;        cin &gt;&gt; l &gt;&gt; r;        query.push_back(&#123;l, r&#125;);    // 存放查询操作的数据对        alls.push_back(l);          // 存放查询用到的下标        alls.push_back(r);    &#125;        // 对alls离散化操作    // 1. 去重：排序 + 去重    sort(alls.begin(), alls.end());    alls.erase(unique(alls.begin(), alls.end()), alls.end());        // 2. 映射坐标，进行相应操作    for(auto item : add)    &#123;        int x = find(item.first);        a[x] += item.second;    &#125;        for(int i = 1; i &lt;= alls.size(); i++)        s[i] = s[i-1] + a[i];        for(auto item : query)    &#123;        int l = find(item.first), r = find(item.second);        cout &lt;&lt; s[r] - s[l-1] &lt;&lt; endl;    &#125;            return 0;&#125;\n\n\n\n例题2：759. 格子染色\n区间合并题型\n给定 n 个区间[li,ri]，要求合并所有有交集的区间\n\n注意如果在端点处相交，也算有交集（有公共端点）\n\n输出合并完成后的区间个数\n\n\n思路\n按区间左端点排序\n以左端点为基准，当前区间与之后的区间有三种情况\n\n\n例题：803. 区间合并\n// segs 存放所有区间的首、尾端点void merge(vector&lt;PII&gt; &amp;segs)&#123;    vector&lt;PII&gt; res;        // 按左端点进行排序    sort(segs.begin(), segs.end());        // 设定为最边界（范围边界*2）    int begin = -2e9, end = -2e9;    for(auto seg : segs)        // 1. 满足上图无交集的情况，且不是初始值时        if(end &lt; seg.first)        &#123;            if(begin != -2e9)                res.push_back(&#123;begin, end&#125;);\t// 保存答案            begin = seg.first, end = seg.second;\t// 更新当前区间        &#125;    \t// 2. 满足上图中①、②情况，更新为区间并集        else            end = max(end, seg.second);        // 保存最后begin-end维护的区间    if(begin != -2e9)        res.push_back(&#123;begin, end&#125;);            segs = res;&#125;\n\n\n\n参考算法基础课模板\n算法基础课\n","categories":["数据结构与算法"],"tags":["数据结构","算法"]},{"title":"高精度","url":"/2023/08/15/algo/high_accuracy/","content":"\nC++ 选手需要处理大整数运算\n\nC++ 存储大整数的方式：将每一位存储到数组中，下标0元素对应个位、1元素对应十位…，依次类推（高位存储在数组末端，方便在运算时进行进位操作）\n\n\n常用运算模板\n\nA + B 型（两大整数相加）：（位数）len(A) &lt;=  10^6，len(B) &lt;=  10^6\nA - B 型（两大整数相减）：len(A) &lt;=  10^6，len(B) &lt;=  10^6\nA * b 型（大整数乘小整数）：len(A) &lt;=  10^6，b &lt;= 10^9\nA &#x2F; b 型（大整数除小整数）\n\n从题中读入、输出大整数// 已知输入为两行，分别为大整数 A 和 B#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123;    // 大整数用字符串先读入    string a, b;    vector&lt;int&gt; A, B;        cin &gt;&gt; a &gt;&gt; b;        // 存入 vector（e.g. &quot;123456&quot; -&gt; [6,5,4,3,2,1]）    for(int i = a.size() - 1; i &gt;= 0; i--)        // 存数字，字符要减去偏移量&#x27;0&#x27;        A.push_back(a[i] - &#x27;0&#x27;);    for(int i = b.size() - 1; i &gt;= 0; i--)        B.push_back(b[i] - &#x27;0&#x27;);        // 进行操作    auto C = func(A, B);        // 读入和输出都是从最高位开始    for(int i = C.size() - 1; i &gt;= 0; i--)        printf(&quot;%d&quot;, C[i]);        return 0;&#125;\n\n\n\n\n\nA + B 型Ci = (Ai + Bi + ti)%10, ti = (Ai-1 + Bi-1)/10\n// C = A + B, A &gt;= 0, B &gt;= 0vector&lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123;    if(A.size() &lt; B.size())\treturn add(B, A);        vector&lt;int&gt; C;    int t = 0;    for(int i = 0; i &lt; A.size(); i++)    &#123;        // 加上进位，如果有B[i]也加上        t += A[i];        if(i &lt; B.size()) t += B[i];                // 取余为i位的值，保存进位t        C.push_back(t % 10);        t /= 10;    &#125;        if(t) C.push_back(t);        return C;&#125;\n\n例题：791.高精度加法\nA - B 型\n先判断 A 和 B 的大小，选择运算次序\n\n// 判断 A &gt;= B bool cmp(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123;    if(A.size() != B.size()) return A.size() &gt; B.size();        for(int i = A.size() - 1; i &gt;= 0; i--)        if(A[i] != B[i])            return A[i] &gt; B[i];        return true;\t// 包含A == B的情况&#125;// C = A - B, A &gt;= B, A &gt;= 0, B &gt;= 0vector&lt;int&gt; sub(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123;    vector&lt;int&gt; C;        // 已保证 A &gt;= B    for(int i = 0, t = 0; i &lt; A.size(); i++)    &#123;        // 减去上一位借位        t = A[i] - t;                // 判断 B 是否有这一位        if(i &lt; B.size())             t -= B[i];                // 精妙处理！：综合处理两种情况：1. t&gt;=0, 即t；2. t&lt;0, 借一位        C.push_back((t + 10) % 10);                // 判断是否需要借一位        if(t &lt; 0) t = 1;        else t = 0;    &#125;        // 去掉高位存在的0    while(C.size() &gt; 1 &amp;&amp; C.back() == 0)        C.pop_back();        return C;&#125;\n\n例题：792. 高精度减法\nA * b 型// C = A * b, A &gt;= 0, b &gt;= 0vector&lt;int&gt; mul(vector&lt;int&gt; &amp;A, int b)&#123;    vector&lt;int&gt; C;        int t = 0;        // &quot;||t&quot; 条件表示进位 t 还没处理完    for(int i = 0; i &lt; A.size() || t; i++)    &#123;        if(i &lt; A.size()) \t\t\t// 如果A还没处理完：t = 上一位的进位 + A[i]*b            t += A[i] * b;                // 每次只考虑取余得到的个位和进位（下一位的个位）        C.push_back(t % 10);        t /= 10;    &#125;        // 去掉高位存在的0    while(C.size() &gt; 1 &amp;&amp; C.back() == 0)        C.pop_back();        return C;&#125;\n\n例题：793. 高精度乘法\nA &#x2F; b 型// C = A / b 余 r, A &gt;= 0, b &gt; 0// 余数 r 用的是实参（答案可能要用到）vector&lt;int&gt; div(vector&lt;int&gt; &amp;A, int b, int &amp;r)&#123;    vecotr&lt;int&gt; C;    r = 0;        for(int i = A.size() - 1; i &gt;= 0; i--)    &#123;        // 按照除法的逻辑：上一位的余数补在A[i]的左边一位        r = r * 10 + A[i];                // 保存当前位，以及余数 r        C.push_back(r / b);        r %= b;    &#125;        // C的开头存储的是数字的高位，需要调转    reverse(C.begin(), C.end());        // 删掉高位的0    while(C.size() &gt; 1 &amp;&amp; C.back() == 0)        C.pop_back();    return C;&#125;\n\n例题：794. 高精度除法\n参考算法基础课模板\n算法基础课\n","categories":["数据结构与算法"],"tags":["数据结构","算法"]},{"title":"KMP字符串匹配","url":"/2023/08/05/algo/kmp/","content":"\nKMP 是由 Knuth，Morris，Pratt 三人设计的线性时间字符串匹配算法\n\n\n\n题目链接：831.KMP字符串\n暴力解法for(int i = 1; i &lt;= n; i++)&#123;  bool flag = true; \tfor(int j = 1; j &lt;= m; j++)  &#123;    if(s[i+j-1] != p[j])    &#123;      flag = false;      break;    &#125;  &#125;&#125;\n\n\n\n使用 KMP 优化用到的概念s[]：模式串，即被匹配的字符串\np[]：模板串，用模板串去匹配模式串\n前缀：非平凡前缀，指除了最后一个字符外，一个字符串的全部头部组合\n后缀：非平凡后缀，指除了第一个字符外，一个字符串的全部尾部组合\n部分匹配值值：前缀和后缀的最长共有元素的长度\nnext[]数组：部分匹配值表，存储每一个下标对应的部分匹配值\nnext[] 数组详解next[]数组是由对模板串（简称p串）预处理得到\n\nnext[j]表示p[1,j]的部分匹配值（p[1,j]串中前缀和后缀相同字符的最大长度）\n\nnext[j] = i，即p[1,i] = p[j - i + 1, j]\n\n\n​\t\n求 next[] 数组过程：通过模板串自己与自己进行匹配得到（匹配过程类似KMP匹配）\nfor(int i = 2, j = 0; i &lt;= n; i++)\t// 根据后缀定义，从第二个字符开始匹配&#123;  \twhile(j &amp;&amp; p[i] != p[j + 1])\tj = ne[j];    \tif(p[i] == p[j+1])\tj++;\t// 下一个位置匹配成功，移动    \tne[i] = j;\t// 当前长度的字符串匹配成功，记录已经匹配的长度（即前缀长度 = 后缀长度 = j）&#125;\n\n\n\n\n\nKMP匹配过程这里 s串和 p串都是从下标1开始\n​\t\n匹配过程如上图所示：\n\n当s[a,b]与p[1,j]匹配，但下一个位置s[i] != p[j+1]时，要移动 p串\n区别于暴力解法，p 串并非向后移动1位，而是直接移动到下次能匹配该部分的位置（② 对应 ①）\n这种移动操作可由j = next[j]完成\n\n// KMP 匹配过程for(int i = 1, j = 0; i &lt;= m; i++)&#123;\t\twhile(j &amp;&amp; s[i] != p[j + 1]) j = ne[j];  \t// 1. j != 0 表示j没有退回起点，并非从头开始匹配  \t// 2. s[i] != p[j+1] 说明当前位置的下一个字符并不匹配  \t// j = ne[j] 调用next[j]，将模板串后移到后缀位置    \tif(s[i] == p[j + 1]) j++;  \t// 下一个位置匹配成功   \t \tif(j == n)\t// 整个模板串匹配成功 \t\t&#123;   \t printf(&quot;%d &quot;, i - n);\t// 匹配成功   \t j = ne[j];\t\t// 继续匹配下一个位置 \t \t&#125;&#125;\n\n\n\n完整代码#include &lt;iostream&gt;using namespace std;const int N = 1e5 + 10, M = 1e6 + 10;int n, m;char p[N], s[M];int ne[N];  // next数组（以防当作保留字报错）int main()&#123;    cin &gt;&gt; n &gt;&gt; p + 1 &gt;&gt; m &gt;&gt; s + 1;\t// &quot;+1&quot;表示下标从1开始        // 求next数组过程    for(int i = 2, j = 0; i &lt;= n; i++)    &#123;        while(j &amp;&amp; p[i] != p[j + 1]) j = ne[j];        if(p[i] == p[j + 1]) j++;        ne[i] = j;    &#125;        // kmp匹配过程     for(int i = 1, j = 0; i &lt;= m; i++)     &#123;         while(j &amp;&amp; s[i] != p[j + 1]) j = ne[j];         if(s[i] == p[j + 1]) j++;         if(j == n)         &#123;             printf(&quot;%d &quot;, i - n);             j = ne[j];              &#125;     &#125;     return 0;&#125;\n\n时间复杂度： O(N)\n参考\n题解：KMP 字符串\nacwing 算法基础课（数据结构 (一) ）\n\n","categories":["数据结构与算法"],"tags":["数据结构","算法"]},{"title":"前缀和 | 差分","url":"/2023/08/20/algo/prefix_sum_and_difference/","content":"前缀和一维前缀和\n用法：快速求原数组中的一段数的和，时间复杂度：O(1)（不需要使用循环 O(N)）\n\n\n\n一维前缀和定义：\n原数组：a1, a2, a3, ..., an（数组下标从1开始！）\n前缀和数组：S1, S2, S3, ..., Sn，其中Si = a1 + a2 + ... + ai（下标也是从1开始，定义S0 = 0）\n求 Si\nfor(int i = 1; i &lt;= n; i++)\tSi = Si-1 + ai;\n求[l, r]这一段数的和：sum = Sr - Sl-1\t\t\n\n消除边界情况的差异，一般使前缀和从 1 开始，而数组也从下标 1 开始\n\n// 模板：求数组 a 中从 l 到 r 的和int a[N];int s[N];// 数组 s 和 a 都是从下标 1 开始存放元素，即 1~n 存放元素for(int i = 1; i &lt;= n; i++)\t    s[i] - s[i-1] = a[i];\t// 前缀和初始化sum = s[r] - s[l-1];\t\t// 区间和的计算\n\n例题：795. 前缀和\n二维前缀和\n用法：快速求出区域矩阵内的元素和\n\n求 Sij\n（方框内的点表示元素） \nfor(int i = 1; i &lt; n; i++)    for(int j = 1; j &lt; m; j++)        s[i][j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1] + a[i][j];\n\n\n\n求区域和：\n\n即整个区域减去两个矩形区域，再补上重复减去的区域\n\n​\t\nsum = s[x2][y2] - s[x2][y1-1] - s[x1-1][y2] + s[x1-1][y1-1];\n\n// 模板：求(x1, y1)和(x2, y2)区域内元素的和int a[N][N];int s[N][N];// 数组 s 和 a 都是从下标 1 开始存放元素，即 1~n 存放元素// 二维前缀和初始化for(int i = 1; i &lt;= n; i++)    for(int j = 1; j &lt;= m; j++)        s[i][j] = s[i][j-1] + s[i-1][j] - s[i-1][j-1] + a[i][j];// 求区域元素和sum = s[x2][y2] - s[x1-1][y2] - s[x2][y1-1] + s[x1-1][y1-1];\n\n\n\n例题：796. 子矩阵的和\n差分\n差分是前缀和的逆运算\n\n一维差分定义和用法差分定义\n\n这里的a、b数组都是从下标1开始\n\n\n原数组：a1, a2, a3, ..., an\n\n构造：b1, b2, b3, ..., bn\n\n使得：ai = b1 + b2 + b3 + ... + bi\n\n\n\n则 a 是 b 的前缀和，b 是 a 的差分\n\n用法：给区间[l, r]中的每个数加上c，求加后序列，使得时间复杂度 O(1)（无需遍历）\t\n\n已知数组b[n]，求新的数组a[1], ..., a[l]+c, a[l+1]+c, ...a[r]+c, a[r+1], ...,a[n]\n\n方法：只需修改：b[l]+c和b[r+1]-c即可求和\n\n\n修改b[l]为b[l]+c：使得a数组变为a[1], ..., a[l]+c, a[l+1]+c, ..., a[n]+c\n修改b[r+1]为b[r+1]-c：使得a数组从a[r+1]开始删掉加上的c\n\n// 差分的插入操作void insert(int l, int r, int c)&#123;    b[l] += c;\t\t    b[r + 1] -= c;&#125;\n\n构造差分数组// 方法一：根据定义进行构造// b[1] = a[1] - a[0] (a[0] == 0)// b[2] = a[2] - s[1]// ...for(int i = 1; i &lt;= n; i++)\tb[i] = a[i] - a[i-1];\n\n// 方法二：利用差分数组的插入操作直接进行构造for(int i = 1; i &lt;= n; i++)    insert(i, i, a[i]);\t// 函数定义在下面// 理解：相当于直接将初始数组转换为其差分数组// 即在[1,1]插入a[1]，在[2,2]插入a[2]，...b[1] = a[1], b[2] = -a[1];b[2] = a[2] - a[1], b[3] = -a[2];...b[i] = a[i] - a[i-1], b[i+1] = -a[i];...b[n] = a[n] - a[n-1], b[n+1] = -a[n];\t// 成功构造出差分数组 b\n\n模板// 1. 定义插入操作void insert(int l, int r, int c)&#123;    b[l] += c;\t\t    b[r + 1] -= c;&#125;// 2. 构造差分数组int b[N];for(int i = 1; i &lt;= n; i++)    insert(i, i, a[i]);// 3. 进行插入操作insert(l, r, c);// 4. 得到改变后的序列，即数组b的前缀和数组，即是要求的新序列数组for(int i = 1; i &lt;= n; i++)    b[i] += b[i - 1];\n\n例题：797. 差分\n二维差分使用差分矩阵逆向二维前缀和，原矩阵a[i][j]，差分矩阵b[i][j]，原矩阵是差分矩阵的前缀和\n用法：给子矩阵的每个元素加上常数 c，输出更改后的矩阵（时间复杂度达到 O(1)）\n\n\n修改b[x1][y1]+c，使得b[x1][y1]到b[xn][yn]都加上c\n修改b[x1][y2+1]-c、b[x2+1][y1]-c，使内部蓝色矩形以外的减去c\n修改b[x2+1][y2+1]+c，使红色矩阵补上额外减去的c\n\n// 差分矩阵的插入操作insert(int x1, int y1, int x2, int y2, int c)&#123;    b[x1][y1] += c;    b[x1][y2+1] -= c;    b[x2+1][y1] -= c;    b[x2+1][y2+1] += c;&#125;\n\n构造差分矩阵// 类似构造差分数组的第二种方法for(int i = 1; i &lt;= n; i++)    for(int j = 1; j &lt;= n; j++)        insert(i, j, i, j, a[i][j]);\n\n例题：798.  差分矩阵\n追加练习leetcode: 238. 除自身以外数组的乘积\n\n利用前缀积*后缀积解决\n时间复杂度O(N)，额外空间复杂度O(1)题解\n\nleetcode: 560. 和为 K 的子数组\n\n利用前缀和 + 哈希\n\n参考算法基础课模板\n算法基础课\n差分题解\n差分矩阵题解\n","categories":["数据结构与算法"],"tags":["数据结构","算法"]},{"title":"快速排序 | 归并排序","url":"/2023/06/24/algo/sort/","content":"\n分治算法基本三部：1. 分成子问题；2. 递归处理子问题；3. 子问题合并\n\n快速排序和归并排序都是基于分治的思想\n\n\n快速排序算法思想\n基于分治的思想：\n\n\n确定分界点：左边界q[l]，中间值q[(l+r)/2]，右边界q[r]，也可以随机\n调整区间：通过 x 的值，划分区间（x 左边≤x，右边≥x）△\n递归：递归处理左、右区间\n\n\n\n// 快排模板void quick_sort(int q[], int l, int r)&#123;    if(l &gt;= r) return;\t   \t    int i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1];    while(i &lt; j)    &#123;        do i++; while(q[i] &lt; x);        do j--; while(q[j] &gt; x);        if(i &lt; j) swap(q[i], q[j]);\t    &#125;    quick_sort(q,l,j);    quick_sort(q,j+1,r);&#125;// 参考：https://www.acwing.com/activity/content/code/content/39784/\n\n细节剖析// 快排模板void quick_sort(int q[], int l, int r)&#123;    // 判断边界，只有一个数/没有数则直接返回，也可以写作 ”l == r“    if(l &gt;= r) return;\t   \t    // 分成子问题    int i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1];    while(i &lt; j)    &#123;        do i++; while(q[i] &lt; x);        do j--; while(q[j] &gt; x);        if(i &lt; j) swap(q[i], q[j]);\t// swap,交换两个数    &#125;        // 递归处理子问题    quick_sort(q, l, j);    quick_sort(q, j+1, r);        // 子问题合并（此处不需要）&#125;\n\n语法补充\nl + r &gt;&gt; 1\t当左侧为非负数时，相当于 (l + r) &#x2F; 2（为负奇数时，会有区别）\ndo i++; while(q[i] &lt; x); 就是一个 do-while 循环\ndo&#123;    i++;&#125;while(q[i] &lt; x);    // 等价写法\n\n思路理解\n\n确定枢轴 x（这里选择的是数组中间的值）\n设置两个指针i, j，分别从数组两侧向中间移动\n利用循环，使得q[l...i] &lt;= x 且 q[j...r] &gt;= x\n递归排列左右两部分\n\n子问题理解\nint i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1];// 由于后面使用的是 do-while 循环，先增减再操作，需要确保从左右端开始\n\n使用 do-while：保证先递增，使得循环可以继续进行\n使用 while 可能会死循环（例：q[i] 和 q[j] 都等于 x 时，i j 不会更新，外层 while 循环卡死）\ndo i++; while(q[i] &lt; x);\t// 使 q[l...i-1] &lt;= x，q[i] &gt;= x     do j--; while(q[j] &gt; x);// 使 q[j+1...r] &gt;= x，q[j] &lt;= x     if(i &lt; j) swap(q[i], q[j]);\t// 交换，使得 q[l...i] &lt;= x，q[j...r] &gt;= x/* 边界问题：如果上述 do-while 循环的条件为 ≥ 或 ≤ \t\t假设数组 q[l...r] 内元素全相等，\t \t则语句 do i++; while(q[i] &lt;= x); 会执行到 r + 1\t \t然后执行 a[i] &lt;= x 也成立，则会一直循环下去；\t \t最终报错：Meomory Limit Exceeded. */\n\n如何得到递减序列？while(i &lt; j)&#123;    do i++; while(q[i] &gt; x);\t    // 此处比较运算符更改一下，循环结果取得 q[i] &lt;= x    do j--; while(q[j] &lt; x);    if(i &lt; j) swap(q[i], q[j]);\t&#125;\n\n参考：acwing 算法基础课\n例题：785. 快速排序\n归并排序算法思想\n基于分治的思想\n\n\n确定分界点，取数组下标中间值\n\n递归排序 left，right\n\n归并，合二为一 △（O(N)）\n\n\n// 归并模板void merge_sort(int q[], int l, int r)&#123;    if (l &gt;= r) return;    int mid = l + r &gt;&gt; 1;\t    merge_sort(q, l, mid);    merge_sort(q, mid + 1, r);    int k = 0, i = l, j = mid + 1;    while (i &lt;= mid &amp;&amp; j &lt;= r)        if (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];        else tmp[k ++ ] = q[j ++ ];    while (i &lt;= mid) tmp[k ++ ] = q[i ++ ];    while (j &lt;= r) tmp[k ++ ] = q[j ++ ];    for (i = l, j = 0; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];&#125;// 参考：https://www.acwing.com/blog/content/277/\n\n细节理解void merge_sort(int q[], int l, int r)&#123;    if (l &gt;= r) return;    // 分治第一步：分成子问题    int mid = l + r &gt;&gt; 1;\t/// 划分，取得区间中点            // 第二步：递归处理子问题    merge_sort(q, l, mid);\t// 递归排序左右区间    merge_sort(q, mid + 1, r);    // 第三步：合并子问题    int k = 0, i = l, j = mid + 1;   \t// i 指向左半边起点，j 指向右半边起点        while (i &lt;= mid &amp;&amp; j &lt;= r)\t// 当左右区间都没有循环为空时        // 取小的存入数组        if (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];\t        else tmp[k ++ ] = q[j ++ ];    // 把剩余没有为空的半边的数接入数组    while (i &lt;= mid) tmp[k ++ ] = q[i ++ ];    while (j &lt;= r) tmp[k ++ ] = q[j ++ ];    // 将临时数组的序列存回 q 数组中    for (i = l, j = 0; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];&#125;\n\nfor (i = l, j = 0; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];\n使用两个控制变量？根据前面定义的int k = 0；，在每次递归中，临时数组都是从下标0位置开始存放数据，而对于数组q，在递归中需要排序的范围是l-r，所以这里需要两个控制变量来转存\n// 使用一个控制变量的写法void mergeSort(int q[], int l, int r)&#123;    if(l &gt;= r)  return;        int mid = l + r &gt;&gt; 1;        mergeSort(q, l, mid);    mergeSort(q, mid + 1, r);    // 区别1：在每次递归中，都从临时数组的 &quot;l&quot; 位置开始存放数据    int i = l, j = mid + 1, k = l;      while(i &lt;= mid &amp;&amp; j &lt;= r)&#123;        if(q[i] &lt;= q[j])\ttemp[k++] = q[i++];        else\ttemp[k++] = q[j++];    &#125;    while(i &lt;= mid)\ttemp[k++] = q[i++];    while(j &lt;= r)\ttemp[k++] = q[j++];        // 区别2：这样针对递归中的每个 q[l...r]，    // 都可以有对应的 temp[l...r]，只用一个控制变量    for(i = l; i &lt;= r; i++) q[i] = temp[i];     &#125;\n\n\n\n参考课程：acwing 算法基础课\n例题：787. 归并排序\t788. 逆序对的数量\n","categories":["数据结构与算法"],"tags":["数据结构","算法"]},{"title":"双指针","url":"/2023/09/10/algo/two_pointers/","content":"核心思想：使用双指针扫描两个（两部分）序列，将朴素算法（两层循环）O(N^2)优化到O(N)\n一般解题思路：先思考暴力解法，再向双指针的方向优化\n\n\n标准模板\n双指针指向两个序列（如归并）\n双指针指向一个序列（如快排）\n\n// 双指针通用模板for(i = 0, j = 0; i &lt; n; i++)\t// j 也可能从其他位置开始&#123;    // 每次移动 i 指针时，考虑更新 j 指针    while(j &lt; i &amp;&amp; check(i, j))        j++;        // 题目具体逻辑&#125;\n\n例题-思考过程题目：799. 最长连续不重复子序列\n// 思考过程// 朴素做法（暴力解法）：O(n^2)for(int i = 0; i &lt; n; i++)    for(int j = 0; j &lt; n; j++)        if(check(j, i))        \tres = max(res, i - j + 1);// 双指针算法// 以 i 指针遍历序列，区间[j,i]内的元素表示最大不重复子序列// 即以 i 为右边界，找“离 j 最远的 i”，就是最大不重复子序列// 当遇到重复时，更新 j = ifor(int i = 0, j = 0; i &lt; n; i++)&#123;    while(j &lt;= i &amp;&amp; check(j, i))\t        j++;    res = max(res, i - j + 1);&#125;\n\n// 处理重复元素的思路：空间换时间（数据不是很大时适用）#include &lt;iostream&gt;using namespace std;const int N = 1e5 + 10;int a[N], s[N];int n;int main(void)&#123;    cin &gt;&gt; n;    for(int i = 0; i &lt; n; i++)\tscanf(&quot;%d&quot;, &amp;a[i]);    int res = 1；\t        // 双指针：i 指针遍历数组，同时用 j 指针指向距离 i 最远的不重复子数组    for(int i = 0, j = 0; i &lt; n; i++)    &#123;        // 开辟数组 s，存放 i 位置数字 a[i] 出现的次数        s[a[i]]++;                // 当元素 a[i] 重复（j一定小于i，省略判断）        while(s[a[i]] &gt; 1)\t        &#123;             // j 从当前位置开始移动，同时删除从当前位置到与a[i]重复的位置之间的元素出现次数            // 直到区间[j,i]内不包含重复元素停止            s[a[j]]--;\t\t            j++;        &#125;                // 记录从 i 到 j 之间的最大距离，即最大不重复子数组的长度        res = max(res, i - j + 1);    &#125;        cout &lt;&lt; res &lt;&lt; endl;    return 0;&#125;\n\n题目：66. 两个链表的第一个公共结点\n\n双指针遍历双链表相同长度后相遇 思路题解\n\n题目补充leetcode: 3. 无重复字符的最长子串\n\n同样是利用数组记录（处理）重复元素\n条件“英文字母、数字、符号和空格组成”表示ascii前128个，只需开大小为128的数组即可\n后续掌握哈希&#x2F;桶等精进算法\n\n参考算法基础课模板\n算法基础课\n","categories":["数据结构与算法"],"tags":["数据结构","算法"]},{"title":"搞定操作系统","url":"/2023/12/23/cs/OS/","content":"参考博客：图解系统，阿秀：操作系统\n\n\n知识点大纲参考：图解系统\n硬件结构冯诺依曼模型\n内存\n\n中央处理器 CPU\n\n总线\n\n输入、输出设备\n\n\n问题记录\n零拷贝？\n\n","categories":["计算机基础"],"tags":["OS","基础","cs"]},{"title":"Go 基础学习","url":"/2023/11/27/language/basic_go/","content":"\nGolang 启动!!!!!\n\n参考博客：Go语言学习之路&#x2F;Go语言教程\n\n\n知识点大纲&#x2F;要点变量和常量\n变量声明方式：标准声明，批量声明\n初始化（可以一次初始化&#x2F;赋值多个变量，a, b = 4, 3.1415926）\n类型推导\n短变量声明（:=，只能在函数内使用）【常用】\n匿名变量（_）\n常量（const，通常定义在全局）\niota常量计数器（跳过、插队、定义数量级、多个iota）\n\n基本数据类型\n整型：有符号、无符号，特殊整型（不使用的情况） \n数字字面量：十进制、八进制（0开头，%o）、十六进制（0x开头，%x），二进制（十进制打印为二进制%b)\n浮点数：float32，float64（%f，%.2f）\n布尔值：默认false，不允许从整型强制转换，无法参与数值运算\n字符串：原生数据类型，&quot;&quot;内\n字符串转义符\n多行字符串&#39;&#39;内\n修改字符串\n常用操作：len(str)，拼接+，分隔，str.contains，前后缀判断，子串位置（第一个下标），join操作\n\n\n复数\n字符byte, rune：&#39;&#39;内，%c\n强制类型转换：T()\n\nfmt\n输出：\n\nPrint，Printf，Println\n\n写入文件：Fprint\n\n返回字符串：Sprint\n\nEprint\n\n\n\n格式化占位符\n\n输入：\n\nScan，Scanf，Scanln\nbufio.NewReader\nFscan\nSscan\n\n\n\n运算符\n类似 C++\n--，++是单独的一行语句\n\n流程控制\nif 条件判断：特殊写法（局部变量声明 + 判断）\nfor 循环（省略初始和结束语句（类似while），无限循环）\nfor range键值循环\nswitch case\ncontinue，break\ngoto\n\n数组var a [元素数量]T\t// T：数据类型，数组大小不可变，不同元素数量的数组是不同的类型\n\n\n数组初始化：\n\n初始化列表[2]string&#123;&quot;abc&quot;, &quot;bcd&quot;&#125;\n编译器推测长度[...]bool&#123;&#125;\n索引值方式a := [...]int&#123;1: 1, 3: 5&#125;\n\n\n遍历数组：len(array)得到数组的长度\n\nfor 循环遍历\nfor range 循环遍历\n\n\n二维数组及其遍历\n\n\n\n多维数组只有第一层可以使用...让编译器推测数组长度，内部的&#123;&#125;以,为结尾\n\n\n数组是值类型：赋值和传参会拷贝数组，改变副本不影响本身\n\n切片\n切片是引用类型，基于数组做的一层封装，内部结构包含地址、长度size、容量cap\n\n切片定义方式：\n切片初始化后才能使用！\n\n\nvar a []T\n\n基于数组得到切片：对切片再次切片：s := a[low:high]（简单切片表达式，完整切片表达式a[low, high, max]）\n\n\ncap = max - low；low可以缺省为 0\na := [5]int&#123;1, 2, 3, 4, 5&#125;s := a[1:4]\t\t// &#123;2, 3, 4&#125;：左包含，右不包含s1 := a[:]\t\t// 从头切到尾s2 := s[1:2]\t// &#123;3&#125;// 对切片再次切片时，high的上限变成被切切片的容量\n\n\nmake 函数构造：s := make([]T, size, cap)\n\n切片的使用\nlen()获得切片长度，cap()获得切片容量\n\n切片的本质\n\n切片不能直接比较：s == nil表示切片没有底层数组\n\n\n// 同样长度、容量为0的切片var s1 []int\t// s1 == nil，没有申请内存，需要初始化var s2 []int&#123;&#125;\t// s2 != nil，已经初始化\n\n\n判空：len(s)==0\n\n切片的赋值拷贝：切片赋值给切片后，二者公用一个底层数组\n\n遍历切片（同数组）\n\n\n切片的其他操作\n动态添加元素：s = append(s, 元素1, 元素2)，底层数组容量不够时可以自动扩容（重新申请更大的一块内存）\n\n可以追加切片：s1 = append(s1, s2...)\n\n! 扩容前后的内存地址是不同的\n\n\n切片的扩容策略\n\n使用copy()复制切片：copy(s2, s1)，s2 使用另一个切片空间\n\n从切片中删除元素：s = append(s[:index], s[index+1:]...)\n\n\nmap\nmap 是无序的基于key-value的数据结构，是引用类型，初始化后才能使用\n\nmap 的定义\n推荐初始化map时直接指定容量，只有初始化map后才能继续后续操作\n\n\n定义map：map[keyType]valueType\n初始化map：默认初始值为nil，make(map[keyType]valueType, [cap])分配内存\n\n用法\n添加键值对\n声明时填充元素\n判断是否存在某个键：value, ok := map[key]，ok为bool类型\n遍历：for range遍历，可以同时遍历key, value也可以只遍历key（遍历顺序与添加顺序无关）\n删除键值对：delete(map, key)\n按指定顺序遍历：使用切片将key排序\n元素为map的切片，值为切片的map：\n\n函数定义函数func 函数名(参数) 返回值 &#123;\t// 多个返回值需要用&quot;()&quot;包裹，&quot;,&quot;分隔    ...&#125;\n\n参数\n类型简写\n可变（数量）参数：x ...int（是切片类型），可变参数放在最后\n\n返回值\n多个返回值：也支持类型简写\n返回值命名：在函数定义处定义返回值，不要忘了return\n返回nil\n\n函数进阶\n作用域\n函数类型：类型为func()，可以作为变量使用（赋值给变量，作为另一个函数的参数，作为返回值）\ndefer语句：延迟处理语句（类似栈），处理资源、文件、异常等\n匿名函数：没有函数名func(参数) (返回值) &#123;&#125;，用于实现回调函数和闭包\n赋值给变量\n立即执行\n\n\n闭包：函数 + 外层变量的引用\n内置函数\n\n指针\nGo 指针不能进行偏移和运算，是安全指针\n\n\n重要符号：取地址&amp;，根据地址取值*\n指针类型：*T，（占位符）%p\n内存分配：new、make：\nnew(Type)返回该类型的指针（较少使用）\nmake只用于slice、map、channel\n\n\n\n结构体自定义类型：type MyInt int，定义具有int特性的新的类型，打印类型时会有MyInt类型\n类型别名：type byte = uint8，打印类型时仍然是原类型\nvar a byte = 10fmt.Printf(&quot;%T&quot;, a)\t\t// uint8\n\n结构体基本使用\n结构体成员没有初始化，默认为类型零值，结构体是值类型\n\n\n结构体定义：struct 类型名 struct &#123; ... &#125;\n\n实例化：var a structName，使用.访问字段\n\n匿名结构体：var 实例名 struct&#123; ... &#125;\n\n指针类型结构体：可以直接用.访问，而不用取值（“语法糖”）\n\n取结构体地址实例化\n\n初始化：键值对初始化，值列表初始化\n\n内存布局：结构体占用一块连续内存，空结构体不占空间，Go 结构体的内存对齐\n\n构造函数：是自己实现的构造函数，且返回值一般是结构体指针类型（降低开销）\n\n\n方法和接受者\n方法：可以为自定义类型或结构体类型定义方法\n接受者：指针类型接受者（对接受者直接做操作），值类型接受者（拷贝副本）\n\n结构体进阶\n在为结构体内slice和map字段赋值时根据实际需要，考虑是否需要拷贝后再赋值\n\n\n匿名字段\n嵌套结构体：可以结合匿名字段使用\n可以直接访问内部匿名结构体的字段 \n模拟”继承“\n\n\n字段的可见性：定义的标识符首字母大写（公开），小写（私有，仅当前包可见）\nJSON 序列化与反序列化：json 包无法访问首字母小写的字段\n结构体标签 Tag\n\n// 字段必须按照标准写法，由一对反引号包裹，key-value之间不要有空格，例如：ID     int    `json:&quot;id&quot;`\n\n\n\n包\n包的定义：（简单理解为放.go的文件夹），包的声明，main包\n包的引入：import packageName &quot;path/packageName&quot;，packageName 可以替换为别名\n可见性：除了对包外可见的变量，首字母都要小写\n匿名导入\ninit初始化函数：全局声明 -&gt; package.init() -&gt; main.init()\n\n\n不允许导入包但不使用，不允许循环引入包\n\n接口\nGo 语言的接口是一种抽象的类型，是一组方法的集合\n\n\n接口不管你是什么类型，只管你要实现什么方法\n\ntype 接口类型名 inference &#123;    // 方法名大写，且接口类型名大写时，该方法可以被其他包的代码访问    方法名1(参数列表1) 返回值列表1\t\t    方法名2(参数列表2) 返回值列表2    ...&#125;\n\n\n使用接口\n值接受者、指针接受者（只有类型指针能够保存到接口变量中）实现接口\n一个类型可以实现多个接口\n接口组合\n空接口：可以存储任意类型的值（作为函数参数、map的值）\n接口值：类型 + 值\n类型断言：v, ok := x.(T)，可以猜测接口变量x的类型T\n\n文件操作用到标准库os\n\n打开和关闭文件\n\n补充&#x2F;提示\n单行注释、多行注释（同 C++）\n\n花括号不能单独另起一行；语句末不需要分号\n\n可在全局声明和初始化变量，但不能单独赋值\n\ngo fmt可以自动格式化代码，使风格统一，会自动调用\n\n使用驼峰命名法\n\n首字母大写的变量&#x2F;结构体是在其他包内可见的，按规范写法需要写注释进行说明\n\n\n问题记录&#x2F;待补充\nother declaration of main：在 Go 中，一个目录（文件夹）就是一个包，一个包只能有一个给定名称的函数（除了init()），不能在同一目录下出现多个同名函数\n\n\n\nmap 为什么是无序的\n\n切片和数组的区别\n\n\n","categories":["编程语言"],"tags":["编程语言","Go"]},{"title":"Hexo 常用操作","url":"/2022/01/23/tech/hexo_operation/","content":"\nHexo 常用命令 | 文章变量设置\n\n\n\n主题使用使用 keep 主题\n主题更新 &#x2F; 样式设置\nPicX 图床\n常用命令hexo new [postName]\t\t# 在 source/_posts 下新建文章hexo new page [pageName]\t\t# 在 source/pageName 下新建页面hexo d\t\t# 将 .deploy 目录部署到 GitHubhexo g\t\t# 生成静态页面至 public 目录hexo s\t\t# 开启预览访问端口（默认 port：4000），ctrl + c 关闭 serverhexo clean\t\t# 清除所有静态页面和缓存数据\n\n\n\nFront-matter# 文章变量设置示例（置于_posts下文章最上方）---title:\t文章标题\t\tdate: 2020-01-21 12:00:00tags:\t[tag1, tag2]categories: [文章分类]&#123;sricky:\t权重值&#125;\t\t# 文章置顶位置&#123;toc:\tfalse&#125;\t\t# 关闭文章目录---# 文章截取符&lt;!--more--&gt;\n","categories":["技术"],"tags":["Hexo"]},{"title":"Go 扩展补充","url":"/2023/12/27/language/ex_go/","content":"\nGolang 启动!!!!!\n\n参考博客：Go语言学习之路&#x2F;Go语言教程\n\n\n常用标准库time 包\n获取时间：time.Now()\nLocation和时区\n时间戳 Unix Time：自1970年1月1日 00:00:00 UTC 至当前时间经过的总秒数\n\n\n","categories":["编程语言"],"tags":["编程语言","Go"]},{"title":"寻找目标","url":"/2023/06/23/life/new_beginning/","content":"叹当下：昨夜西风凋碧树，独上高楼，望尽天涯路。\n愿未来：衣带渐宽终不悔，为伊消得人憔悴。\n","categories":["生活"],"tags":["经历"]},{"title":"数组模拟：单双链表/栈/队列 | 单调栈/队列","url":"/2023/11/25/algo/linklist_stack_queue/","content":"\n数组模拟：链表（单链表、双链表）、栈、队列， 单调栈，单调队列\n\n\n\n数组模拟链表\n不使用动态链表（指针+结构体），因为 new 链表很慢（考虑效率）\n\n\n笔试常用的是使用数组模拟链表\n\n单链表\n常用于邻接表（存储树、图）\n\n\n采用静态链表的方式，数组表示链表\n\ne[N]存放数组的值，ne[N]表示next指针\n\n\n\n\nhead表示头结点的下标（指向链表第一个元素）\ne[i]表示节点i的值\nne[i]表示节点i的next指针是多少\n空节点下标指向-1\nidx存储当前已经用到了哪个点\n\nint head, e[N], ne[N], idx;// 初始化void init()&#123;    head = -1;    idx = 0;    // 都没用到，指向头结点&#125;// 头插法void add_to_head(int x)&#123;    ne[idx] = head;    head = idx;    e[idx] = x;    idx++;&#125;// 插入到第k个结点之后void add(int k, int x)&#123;    e[idx] = x;    ne[idx] = ne[k];    ne[k] = idx;    idx++;&#125;// 删掉第k个结点后面的结点void remove(int k)&#123;    ne[k] = ne[ne[k]];&#125;\n\n例题：826. 实现单链表\n双链表\n用来优化某些问题\n\n省略定义头、尾结点，用下标 0 表示头 head，下标 1 表示尾 tail\n\ne[i]表示结点的值\nl[i]表示i前驱结点\nr[i]表示i后继结点\nidx 存储当前已经用到了哪个结点\n\nint e[N], l[N], r[N], idx;// 初始化void init()&#123;    // 0表示左端点，1表示右端点    // 初始情况：    r[0] = 1, l[1] = 0;        // 前两个已经被占用了    idx = 2;&#125;// 在第k个点右插xvoid add(int k, int x)&#123;    r[idx] = r[k], l[idx] = k;    l[r[k]] = idx;    r[k] = idx;    e[idx] = x;    idx++;&#125;// 删除第k个点void remove_k(int k)&#123;    r[l[k]] = r[k], l[r[k]] = l[k];&#125;\n\n例题：827. 双链表\n\n栈：后进先出，队列：先进先出\n\n数组模拟栈int stk[N], tt;\t// tt 表示栈顶下标// 插入stk[++tt] = x;// 删除tt--;// 判空if(tt &gt; 0)\t// not emptyelse\t\t// empty// 得到栈顶元素stk[tt];\n\n\n\n单调栈\n给定序列，求序列中每一个数左边（或右边）离他最近（或满足其他条件）的数\n\n例题： 单调栈（左侧最近最小）\n题型思路：求序列中每一个数左边离它最近，且小于它的数 \n\n先想暴力做法，再通过性质优化\n\n\n思考暴力解法：双循环枚举（时间复杂度O(N^2)，直接超时）\n\n#include &lt;iostream&gt;using namespace std;const int N = 1e5 + 10;// 双循环枚举暴力解法int n, a[N];int main(void)&#123;    cin &gt;&gt; n;    for(int i = 0; i &lt; n; i++)        cin &gt;&gt; a[i];        for(int i = 0; i &lt; n; i++)    &#123;        bool flag = false;        for(int j = i - 1; j &gt;= 0; j--)            if(a[j] &lt; a[i])            &#123;                cout &lt;&lt; a[j] &lt;&lt; &quot; &quot;;                flag = true;                break;            &#125;        if(!flag) cout &lt;&lt; -1 &lt;&lt; &quot; &quot;;    &#125;    return 0;&#125;\n\n\n思考单调栈：在遍历数组的同时，用栈存储当前位置左侧的元素\n\n规则：当前为 a[i]，对于栈顶元素 a[tt] 构成逆序时（即 tt &lt; i 且 a[tt] &gt;&#x3D; a[i]），则弹出栈顶直至栈顶小于 a[i]；\n  按照这种方式入栈，得到的是单调栈，且栈顶即是 a[i] 满足题意条件的数\n\n思路：a[i] 左侧的逆序数将永远不会被当做答案（a[i] 用不到，对于 a[i] 右侧的数，a[i] 显然是更好的选择）\n\n时间复杂度：每个元素 x 最多只会进栈和出栈一次，最多 2N，即时间复杂度为 O(N)\n\n\n\n\n#include &lt;iostream&gt;using namespace std;const int N = 1e5 + 10;int n, tt, stk[N];int main(void)&#123;    scanf(&quot;%d&quot;, &amp;n);\t// 使用 scanf 速度要快几倍    for(int i = 0; i &lt; n; i++)    &#123;        int x;        scanf(&quot;%d&quot;, &amp;x);        while(tt &amp;&amp; stk[tt] &gt;= x) tt--;        if(tt)            cout &lt;&lt; stk[tt] &lt;&lt; &quot; &quot;;        else             cout &lt;&lt; -1 &lt;&lt; &quot; &quot;;                stk[++tt] = x;    &#125;  \t\treturn 0;&#125;\n\n\n\n\n\n数组模拟队列int q[N], hh, tt;\t// 队头 hh，队尾 tt// 队尾插入q[++tt] = x;// 队头弹出hh++;// 判空if(hh &lt;= tt)\t// not emptyelse\t\t\t// empty    // 取出队头元素q[hh]\n\n单调队列（后续二刷理解）滑动窗口求最值：输出每次滑动窗口移动后的最大最小值    滑动窗口\n\n思考暴力做法：用队列维护窗口，遍历得到最值\tO(nk) \n\n用单调队列优化：考虑队列中没用的元素\n\n如果存在逆序关系，则先进队列的元素一定不是最小值\n\n对于得到的单调队列，队头即是最小元素\n\n\n\n\n#include &lt;iostream&gt;using namespace std;const int N = 1e6 + 10;int n, k;int a[N], q[N];int main(void)&#123;    scanf(&quot;%d%d&quot;, &amp;n, &amp;k);    for(int i = 0; i &lt; n; i++)\tscanf(&quot;%d&quot;, &amp;a[i]);            int hh = 0, tt = -1;        for(int i = 0; i &lt; n; i++)    &#123;      // 判断队头是否已经滑出窗口        if(hh &lt;= tt &amp;&amp; i - k + 1 &gt; q[hh])            hh++;        while(hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i])            tt--;        q[++tt] = i;        if(i &gt;= k - 1)             cout &lt;&lt; a[q[hh]] &lt;&lt; &quot; &quot;;    &#125;        puts(&quot;&quot;);        hh = 0, tt = -1;        for(int i = 0; i &lt; n; i++)    &#123;        if(hh &lt;= tt &amp;&amp; i - k + 1 &gt; q[hh])            hh++;        while(hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i])            tt--;        q[++tt] = i;        if(i &gt;= k - 1)             cout &lt;&lt; a[q[hh]] &lt;&lt; &quot; &quot;;    &#125;        puts(&quot;&quot;);        return 0;&#125;\n\n","categories":["数据结构与算法"],"tags":["数据结构","算法"]}]