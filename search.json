[{"title":"寻找目标","url":"/2023/06/23/Hello-MyBlog/","content":"叹当下：昨夜西风凋碧树，独上高楼，望尽天涯路。\n愿未来：衣带渐宽终不悔，为伊消得人憔悴。\n","categories":["生活"],"tags":["经历"]},{"title":"Hexo 常用操作","url":"/2022/01/23/Hexo%20%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/","content":"\nHexo 常用命令 | 文章变量设置\n\n\n\n主题使用使用 keep 主题\n主题更新 &#x2F; 样式设置\nPicX 图床\n常用命令hexo new [postName]\t\t# 在 source/_posts 下新建文章hexo new page [pageName]\t\t# 在 source/pageName 下新建页面hexo d\t\t# 将 .deploy 目录部署到 GitHubhexo g\t\t# 生成静态页面至 public 目录hexo s\t\t# 开启预览访问端口（默认 port：4000），ctrl + c 关闭 serverhexo clean\t\t# 清除所有静态页面和缓存数据\n\n\n\nFront-matter# 文章变量设置示例（置于_posts下文章最上方）---title:\t文章标题\t\tdate: 2020-01-21 12:00:00tags:\t[tag1, tag2]categories: [文章分类]&#123;sricky:\t权重值&#125;\t\t# 文章置顶位置&#123;toc:\tfalse&#125;\t\t# 关闭文章目录---# 文章截取符&lt;!--more--&gt;\n\n","categories":["技术"],"tags":["Hexo"]},{"title":"KMP字符串匹配","url":"/2023/08/05/KMP%E5%8C%B9%E9%85%8D/","content":"\nKMP 是由 Knuth，Morris，Pratt 三人设计的线性时间字符串匹配算法\n\n\n\n题目链接：831.KMP字符串\n暴力解法for(int i = 1; i &lt;= n; i++)&#123;  bool flag = true; \tfor(int j = 1; j &lt;= m; j++)  &#123;    if(s[i+j-1] != p[j])    &#123;      flag = false;      break;    &#125;  &#125;&#125;\n\n\n\n使用 KMP 优化用到的概念s[]：模式串，即被匹配的字符串\np[]：模板串，用模板串去匹配模式串\n前缀：非平凡前缀，指除了最后一个字符外，一个字符串的全部头部组合\n后缀：非平凡后缀，指除了第一个字符外，一个字符串的全部尾部组合\n部分匹配值值：前缀和后缀的最长共有元素的长度\nnext[]数组：部分匹配值表，存储每一个下标对应的部分匹配值\nnext[] 数组详解next[]数组是由对模板串（简称p串）预处理得到\n\nnext[j]表示p[1,j]的部分匹配值（p[1,j]串中前缀和后缀相同字符的最大长度）\n\nnext[j] = i，即p[1,i] = p[j - i + 1, j]\n\n\n​\t\n求 next[] 数组过程：通过模板串自己与自己进行匹配得到（匹配过程类似KMP匹配）\nfor(int i = 2, j = 0; i &lt;= n; i++)\t// 根据后缀定义，从第二个字符开始匹配&#123;  \twhile(j &amp;&amp; p[i] != p[j + 1])\tj = ne[j];    \tif(p[i] == p[j+1])\tj++;\t// 下一个位置匹配成功，移动    \tne[i] = j;\t// 当前长度的字符串匹配成功，记录已经匹配的长度（即前缀长度 = 后缀长度 = j）&#125;\n\n\n\n\n\nKMP匹配过程这里 s串和 p串都是从下标1开始\n​\t\n匹配过程如上图所示：\n\n当s[a,b]与p[1,j]匹配，但下一个位置s[i] != p[j+1]时，要移动 p串\n区别于暴力解法，p 串并非向后移动1位，而是直接移动到下次能匹配该部分的位置（② 对应 ①）\n这种移动操作可由j = next[j]完成\n\n// KMP 匹配过程for(int i = 1, j = 0; i &lt;= m; i++)&#123;\t\twhile(j &amp;&amp; s[i] != p[j + 1]) j = ne[j];  \t// 1. j != 0 表示j没有退回起点，并非从头开始匹配  \t// 2. s[i] != p[j+1] 说明当前位置的下一个字符并不匹配  \t// j = ne[j] 调用next[j]，将模板串后移到后缀位置    \tif(s[i] == p[j + 1]) j++;  \t// 下一个位置匹配成功   \t \tif(j == n)\t// 整个模板串匹配成功 \t\t&#123;   \t printf(&quot;%d &quot;, i - n);\t// 匹配成功   \t j = ne[j];\t\t// 继续匹配下一个位置 \t \t&#125;&#125;\n\n\n\n完整代码#include &lt;iostream&gt;using namespace std;const int N = 1e5 + 10, M = 1e6 + 10;int n, m;char p[N], s[M];int ne[N];  // next数组（以防当作保留字报错）int main()&#123;    cin &gt;&gt; n &gt;&gt; p + 1 &gt;&gt; m &gt;&gt; s + 1;\t// &quot;+1&quot;表示下标从1开始        // 求next数组过程    for(int i = 2, j = 0; i &lt;= n; i++)    &#123;        while(j &amp;&amp; p[i] != p[j + 1]) j = ne[j];        if(p[i] == p[j + 1]) j++;        ne[i] = j;    &#125;        // kmp匹配过程     for(int i = 1, j = 0; i &lt;= m; i++)     &#123;         while(j &amp;&amp; s[i] != p[j + 1]) j = ne[j];         if(s[i] == p[j + 1]) j++;         if(j == n)         &#123;             printf(&quot;%d &quot;, i - n);             j = ne[j];              &#125;     &#125;     return 0;&#125;\n\n时间复杂度： O(N)\n参考\n题解：KMP 字符串\nacwing 算法基础课（数据结构 (一) ）\n\n","categories":["数据结构与算法"],"tags":["数据结构","算法"]},{"title":"二分法","url":"/2023/06/27/%E4%BA%8C%E5%88%86/","content":"\n二分的本质：在区间中找到满足某种性质的边界，使得区间二分为“不重叠”的两部分，每次选择答案所在的区间进行下一步处理，当区间长度为1时，即得到查找的答案（或可判断为无解）\n\n有单调性一定可以二分，没有单调性也可以二分（二分本质不是单调性）\n\n\n整数二分的两个模板\n两个模板的区别主要是看 mid 属于左边，还是右边，属于右边时 mid &#x3D; (r + l + 1) &#x2F; 2！\n\n\n\n模板一：mid 属于左区间区间[l, r]被划分成[l, mid]和[mid + 1, r]\nbool check(int x) &#123;/* ... */&#125; // 检查x是否满足某种性质int bsearch_1(int l, int r)&#123;    while (l &lt; r)    &#123;        int mid = l + r &gt;&gt; 1;\t\t// 找中间值 (l+r)/2                // check()判断 mid 是否满足性质        if (check(mid)) \t\t\t            r = mid;    \t// 满足（该情况下左区域包含 mid）        else             l = mid + 1;\t// 不满足（从 mid 下一个位置）    &#125;    return l;\t// 最后 l == r，跳出循环&#125;\n\n\n\n模板二：mid 属于右区间区间[l, r]被划分成[l, mid - 1]和[mid, r]\nbool check(int x) &#123;/* ... */&#125; // 检查x是否满足某种性质int bsearch_2(int l, int r)&#123;    while (l &lt; r)    &#123;        int mid = l + r + 1 &gt;&gt; 1;        // 补 +1，当 l = r-1 时，确保不会死循环（两个模板的主要区分点）                if (check(mid))             l = mid;        else             r = mid - 1;    &#125;    return l;&#125;\n\n\n\n整数二分重要思想\n有序数列，查找 — 选取二分法\n\n\n先写 check() 函数\n根据 check(mid) 判断 mid 的值在左 / 右区间，选取模板\n如果无解，记得满足题意\n\n例题：789. 数的范围\n浮点数二分\n浮点数二分不需要区分边界，每次都是严格取得中间值\n\n\n当最终区间范围足够小时，可认为取得最终答案\n\nbool check(double x) &#123;/* ... */&#125; // 检查x是否满足某种性质double bsearch_3(double l, double r)&#123;    const double eps = 1e-6;    // eps 表示精度，取决于题目对精度的要求    \t\t\t\t\t\t\t// 一般是题目要求的精度下探两位    while (r - l &gt; eps)\t\t\t// 也可以是循环 100 次    &#123;        double mid = (l + r) / 2;        if (check(mid))             r = mid;        else             l = mid;    &#125;    return l;&#125;\n\n\n\n参考模板链接\n","categories":["数据结构与算法"],"tags":["数据结构","算法"]},{"title":"前缀和 | 差分","url":"/2023/08/20/%E5%89%8D%E7%BC%80%E5%92%8C%20%7C%20%E5%B7%AE%E5%88%86/","content":"前缀和一维前缀和一维前缀和定义：\n原数组：a1, a2, a3, ..., an\n前缀和数组：S1, S2, S3, ..., Sn，其中Si = a1 + a2 + ... + ai\n求 Si\nfor(int i = 1; i &lt;= n; i++)\tSi = Si-1 + ai;\n用法：快速求原数组中的一端数的和，时间复杂度：**$O(1)$**（不需要使用循环 $O(N)$）\n[l, r], sum = Sr - Sl-1\t\t\n\n消除边界情况的差异，一般使前缀和从 1 开始，而数组也从下标 1 开始\n\n// 前缀和的应用: 求数组 a 中从 l 到 r 的和int a[N];int s[N];// 数组 s 和 a 都是从下标 1 开始存放元素，即 1~n 存放元素for(int i = 1; i &lt;= n; i++)\t    s[i] - s[i-1] = a[i];\t// 前缀和初始化sum = s[r] - s[l-1];\t\t// 区间和的计算\n\n二维前缀和​\t\n求 $S_{ij}$\n​\t（方框内的点表示元素）\nfor(int i = 1; i &lt; n; i++)    for(int j = 1; j &lt; m; j++)        s[i][j] = s[i-1][j] - s[i][j-1] + a[i][j]\n\n用法：快速求出区域矩阵内的元素和\n求和：即整个区域减去两个矩形区域，再补上重复减去的区域\nsum = s[x2][y2] - s[x2][y1-1] - s[x1-1][y2] + s[x1-1][y1-1]\n题目理解：子矩阵的和（模板）\n输入一个 n 行 m 列的整数矩阵，再输入四个整数 x1, y1, x2, y2，表示一个子矩阵的左上角左边和右下角坐标，输出子矩阵所有数的和。\n输入：n, m;\n​\t\t\t接下来 n 行，每行包含 m 个整数，表示整数矩阵\n​\t\t\t输入一行，包含四个整数 x1, y1, x2, y2\n输出：子矩阵所有数的和\n#include &lt;iostream&gt;using namespace std;const int N = 1001;int a[N][N], s[N][N];int n, m;int main(void)&#123;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;        //\t接收数组的同时，得到二维前缀和    for(int i = 1; i &lt;= n; i++)&#123;        for(int j = 1; j &lt;= m; j++)&#123;            scanf(&quot;%d&quot;, &amp;a[i][j]);            s[i][j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1] + a[i][j];        &#125;    &#125;          int x1, y1, x2, y2, sum;     cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;            // 二维前缀和求子矩阵，模板    sum = s[x2][y2] - s[x1-1][y2] - s[x2][y1-1] + s[x1-1][y1-1];            cout &lt;&lt; sum &lt;&lt; endl;    return 0;&#125;\n\n\n\n差分\n差分是前缀和的逆运算\n\n一维差分差分定义：\n\n原数组：a1, a2, a3, ..., an\n\n构造：b1, b2, b3, ..., bn\n\n使得：ai = b1 + b2 + b3 + ... + bi\n\n\n则 a 是 b 的前缀和，b 是 a 的差分\n用法：给区间[l, r]中的每个数加上c，求加后序列\n\n使得时间复杂度 **$O(1)$**（无需遍历）\n\n\t\n\n\n综上，即只需修改b[l]和b[r + 1 ]即可求和-\n\n理解: 初始数组可以看作是在区间[1,1]插入a[i];\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t[2,2]插入a[2]以此类推到[n,n]插入a[n]\n\n即差分只需要一种插入操作\n\n// 模板：给数组指定区间内的每个元素加上常数,求加上后的序列#include &lt;iostream&gt;using namespace std;const int N = 100010;int n;int a[N], b[N];// 差分的插入操作void insert(int l, int r, int c)&#123;    b[l] += c;\t\t    b[r + 1] -= c;&#125;int main(void)&#123;    cin &gt;&gt; n;    for(int i = 1; i &lt;= n; i++)        scanf(&quot;%d&quot;, &amp;a[i]);        // 根据上文理解，得到差分序列 b1, b2,..., bn    for(int i = 1; i &lt;= n; i++)        insert(i, i, a[i]);        int l, r, c;\t\t// 取得区间的左右边界、常数    cin &gt;&gt; l &gt;&gt; r &gt;&gt; c;    insert(l, r, c);\t// 进行插入操作        // 即将 bi 变换成自己的前缀和，对应插入常数后的 ai    for(int i = 1; i &lt;= n; i++)        b[i] += b[i - 1];        for(int i = 1; i &lt;= n; i++)        cout &lt;&lt; b[i] &lt;&lt; &quot; &quot;;        return 0;&#125;\n\n二维差分 逆向二维前缀和，原矩阵a[i][j]，差分矩阵b[i][j]，原矩阵是差分矩阵的前缀和\n用法：给子矩阵的每个元素加上常数 c，输出子矩阵（时间复杂度达到 **$O(1)$**）\n\n\n题目理解：798.  差分矩阵\n// 核心代码int a[N][N];int b[N][N];\t// 差分矩阵\n\n\n\n","categories":["数据结构与算法"],"tags":["数据结构","算法"]},{"title":"快速排序 | 归并排序","url":"/2023/06/24/%E6%8E%92%E5%BA%8F/","content":"\n分治算法基本三部：1. 分成子问题；2. 递归处理子问题；3. 子问题合并\n\n快速排序和归并排序都是基于分治的思想\n\n\n快速排序算法思想\n基于分治的思想：\n\n\n确定分界点：左边界q[l]，中间值q[(l+r)/2]，右边界q[r]，也可以随机\n调整区间：通过 x 的值，划分区间（x 左边≤x，右边≥x）△\n递归：递归处理左、右区间\n\n\n\n// 快排模板void quick_sort(int q[], int l, int r)&#123;    if(l &gt;= r) return;\t   \t    int i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1];    while(i &lt; j)    &#123;        do i++; while(q[i] &lt; x);        do j--; while(q[j] &gt; x);        if(i &lt; j) swap(q[i], q[j]);\t    &#125;    quick_sort(q,l,j);    quick_sort(q,j+1,r);&#125;// 参考：https://www.acwing.com/activity/content/code/content/39784/\n\n细节剖析// 快排模板void quick_sort(int q[], int l, int r)&#123;    // 判断边界，只有一个数/没有数则直接返回，也可以写作 ”l == r“    if(l &gt;= r) return;\t   \t    // 分成子问题    int i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1];    while(i &lt; j)    &#123;        do i++; while(q[i] &lt; x);        do j--; while(q[j] &gt; x);        if(i &lt; j) swap(q[i], q[j]);\t// swap,交换两个数    &#125;        // 递归处理子问题    quick_sort(q, l, j);    quick_sort(q, j+1, r);        // 子问题合并（此处不需要）&#125;\n\n语法补充\nl + r &gt;&gt; 1\t当左侧为非负数时，相当于 (l + r) &#x2F; 2（为负奇数时，会有区别）\ndo i++; while(q[i] &lt; x); 就是一个 do-while 循环\ndo&#123;    i++;&#125;while(q[i] &lt; x);    // 等价写法\n\n思路理解\n\n确定枢轴 x（这里选择的是数组中间的值）\n设置两个指针i, j，分别从数组两侧向中间移动\n利用循环，使得q[l...i] &lt;= x 且 q[j...r] &gt;= x\n递归排列左右两部分\n\n子问题理解\nint i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1];// 由于后面使用的是 do-while 循环，先增减再操作，需要确保从左右端开始\n\n使用 do-while：保证先递增，使得循环可以继续进行\n使用 while 可能会死循环（例：q[i] 和 q[j] 都等于 x 时，i j 不会更新，外层 while 循环卡死）\ndo i++; while(q[i] &lt; x);\t// 使 q[l...i-1] &lt;= x，q[i] &gt;= x     do j--; while(q[j] &gt; x);// 使 q[j+1...r] &gt;= x，q[j] &lt;= x     if(i &lt; j) swap(q[i], q[j]);\t// 交换，使得 q[l...i] &lt;= x，q[j...r] &gt;= x/* 边界问题：如果上述 do-while 循环的条件为 ≥ 或 ≤ \t\t假设数组 q[l...r] 内元素全相等，\t \t则语句 do i++; while(q[i] &lt;= x); 会执行到 r + 1\t \t然后执行 a[i] &lt;= x 也成立，则会一直循环下去；\t \t最终报错：Meomory Limit Exceeded. */\n\n如何得到递减序列？while(i &lt; j)&#123;    do i++; while(q[i] &gt; x);\t    // 此处比较运算符更改一下，循环结果取得 q[i] &lt;= x    do j--; while(q[j] &lt; x);    if(i &lt; j) swap(q[i], q[j]);\t&#125;\n\n参考：acwing 算法基础课\n例题：785. 快速排序\n归并排序算法思想\n基于分治的思想\n\n\n确定分界点，取数组下标中间值\n\n递归排序 left，right\n\n归并，合二为一 △（O(N)）\n\n\n// 归并模板void merge_sort(int q[], int l, int r)&#123;    if (l &gt;= r) return;    int mid = l + r &gt;&gt; 1;\t    merge_sort(q, l, mid);    merge_sort(q, mid + 1, r);    int k = 0, i = l, j = mid + 1;    while (i &lt;= mid &amp;&amp; j &lt;= r)        if (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];        else tmp[k ++ ] = q[j ++ ];    while (i &lt;= mid) tmp[k ++ ] = q[i ++ ];    while (j &lt;= r) tmp[k ++ ] = q[j ++ ];    for (i = l, j = 0; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];&#125;// 参考：https://www.acwing.com/blog/content/277/\n\n细节理解void merge_sort(int q[], int l, int r)&#123;    if (l &gt;= r) return;    // 分治第一步：分成子问题    int mid = l + r &gt;&gt; 1;\t/// 划分，取得区间中点            // 第二步：递归处理子问题    merge_sort(q, l, mid);\t// 递归排序左右区间    merge_sort(q, mid + 1, r);    // 第三步：合并子问题    int k = 0, i = l, j = mid + 1;   \t// i 指向左半边起点，j 指向右半边起点        while (i &lt;= mid &amp;&amp; j &lt;= r)\t// 当左右区间都没有循环为空时        // 取小的存入数组        if (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];\t        else tmp[k ++ ] = q[j ++ ];    // 把剩余没有为空的半边的数接入数组    while (i &lt;= mid) tmp[k ++ ] = q[i ++ ];    while (j &lt;= r) tmp[k ++ ] = q[j ++ ];    // 将临时数组的序列存回 q 数组中    for (i = l, j = 0; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];&#125;\n\nfor (i = l, j = 0; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];\n使用两个控制变量？根据前面定义的int k = 0；，在每次递归中，临时数组都是从下标0位置开始存放数据，而对于数组q，在递归中需要排序的范围是l-r，所以这里需要两个控制变量来转存\n// 使用一个控制变量的写法void mergeSort(int q[], int l, int r)&#123;    if(l &gt;= r)  return;        int mid = l + r &gt;&gt; 1;        mergeSort(q, l, mid);    mergeSort(q, mid + 1, r);    // 区别1：在每次递归中，都从临时数组的 &quot;l&quot; 位置开始存放数据    int i = l, j = mid + 1, k = l;      while(i &lt;= mid &amp;&amp; j &lt;= r)&#123;        if(q[i] &lt;= q[j])\ttemp[k++] = q[i++];        else\ttemp[k++] = q[j++];    &#125;    while(i &lt;= mid)\ttemp[k++] = q[i++];    while(j &lt;= r)\ttemp[k++] = q[j++];        // 区别2：这样针对递归中的每个 q[l...r]，    // 都可以有对应的 temp[l...r]，只用一个控制变量    for(i = l; i &lt;= r; i++) q[i] = temp[i];     &#125;\n\n\n\n参考课程：acwing 算法基础课\n例题：787. 归并排序\t788. 逆序对的数量\n","categories":["数据结构与算法"],"tags":["数据结构","算法"]},{"title":"算法技巧：加快读取速度 | 浮点数保留 | 字符串处理","url":"/2023/06/24/%E7%AE%97%E6%B3%95%E6%8A%80%E5%B7%A71/","content":"\n选择高效的读入方式 | 浮点数处理 | 字符串处理\n\n\n\n选择高效的读入方式\n经验：当输入比较多时，选择高效的读入方式\n\n1. 选择printf/scanf，而非cout/cin\n当 C++ 读读取大量数据时，使用前者甚至可以提速十倍\n尤其是将cin替换为scanf，读取速度可以显著提高\n\n// printf 输出 用法printf(&quot;字符串&quot;);printf(&quot;格式控制符1 输出控制符2...&quot;，输出参数1，输出参数2,...);// 格式控制符，输出参数的个数一一对应printf(&quot;格式控制符 非输出控制符&quot;, 输出参数);// scanf 输入 用法scanf(&quot;格式控制符&quot;, &amp;输入参数);\t// 不要忘记&quot;&amp;&quot;\t// 变量前有 &amp; 表明“放到以变量的地址为地址的变量中”\n\n2. 优化cout/cin// 在main函数内添加如下代码之一ios::sync_with_stdio(false);\t// code1cin.tie(0);\t// code2\n\n\nJava 用buffread，而非Scanner\n\n浮点数处理经验：保留 k 位小数，精度下探两位\n用法：使用cout输出，保留固定位数的小数\n/* 写法一 */#include &lt;iomanip&gt;\t// 需要使用的头文件cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(6) &lt;&lt; a &lt;&lt; endl;// 输出保留6位小数的变量a/* 写法二 */printf(&quot;%.6lf&quot;, a);\t\t// 更简洁\n\n// 使用scanf输入doublescanf(&quot;%lf&quot;, &amp;a);\t\n\n\n\n字符串处理// substr() 字符串指定长度复制str.substr(pos, len)// 返回值 string，包含str中从pos开始的len个字符的拷贝// pos 的默认值为 0，len 的默认值为 s.size() - pos（默认拷贝整个字符串）\n\n语法题：左旋转字符串\n语法题：把字符串转换成整数\n经验：\n\n字符类型的0对应于 ASCII 码48，获得整数需要-&#39;0&#39;\n字符数组存储的元素是数字的判断语句\n\nstr[k] &gt;= &#39;0&#39; &amp;&amp; str[k] &lt;= &#39;9&#39;\n\n可以用1e11为界限判断int类型是否越界\n当结果可能超出范围时，选取更大的类型，并返回时进行强制转换\n\n其他技巧：输入括号后，再输入右括号，可以直接跳出括号而不使用方向键\n","categories":["数据结构与算法"],"tags":["数据结构","算法"]},{"title":"高精度","url":"/2023/08/15/%E9%AB%98%E7%B2%BE%E5%BA%A6/","content":"\nC++ 选手需要处理大整数运算\n\nC++ 存储大整数的方式：将每一位存储到数组中，下标0元素对应个位、1元素对应十位…，依次类推（高位存储在数组末端，方便在运算时进行进位操作）\n\n\n常用运算模板\n\nA + B 型（两大整数相加）：（位数）len(A) &lt;=  10^6，len(B) &lt;=  10^6\nA - B 型（两大整数相减）：len(A) &lt;=  10^6，len(B) &lt;=  10^6\nA * b 型（大整数乘小整数）：len(A) &lt;=  10^6，b &lt;= 10^9\nA &#x2F; b 型（大整数除小整数）\n\n从题中读入、输出大整数// 已知输入为两行，分别为大整数 A 和 B#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123;    // 大整数用字符串先读入    string a, b;    vector&lt;int&gt; A, B;        cin &gt;&gt; a &gt;&gt; b;        // 存入 vector（e.g. &quot;123456&quot; -&gt; [6,5,4,3,2,1]）    for(int i = a.size() - 1; i &gt;= 0; i--)        // 存数字，要减去偏移量&#x27;0&#x27;        A.push_back(a[i] - &#x27;0&#x27;);    for(int i = b.size() - 1; i &gt;= 0; i--)        B.push_back(b[i] - &#x27;0&#x27;);        // 进行操作    auto C = func(A, B);        // 读入和输出都是从最高位开始    for(int i = C.size() - 1; i &gt;= 0; i--)        printf(&quot;%d&quot;, C[i]);        return 0;&#125;\n\n\n\n\n\nA + B 型Ci = (Ai + Bi + ti)%10, ti = (Ai-1 + Bi-1)/10\n// C = A + B, A &gt;= 0, B &gt;= 0vector&lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123;    if(A.size() &lt; B.size())\treturn add(B, A);        vector&lt;int&gt; C;    int t = 0;    for(int i = 0; i &lt; A.size(); i++)    &#123;        t += A[i];        if(i &lt; B.size()) t += B[i];        C.push_back(t % 10);        t /= 10;    &#125;        if(t) C.push_back(t);        return C;&#125;\n\n例题：791.高精度加法\nA - B 型\n先判断 A 和 B 的大小，选择运算次序\n\n// 判断 A &gt;= B bool cmp(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123;    if(A.size() != B.size()) return A.size() &gt; B.size();        for(int i = A.size() - 1; i &gt;= 0; i--)        if(A[i] != B[i])            return A[i] &gt; B[i];   \treturn true;\t// 包含A == B的情况&#125;// C = A - B, A &gt;= B, A &gt;= 0, B &gt;= 0vector&lt;int&gt; sub(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123;    vector&lt;int&gt; C;        // 已保证 A &gt;= B    for(int i = 0, t = 0; i &lt; A.size(); i++)    &#123;        // 减去进位        t = A[i] - t;                // 判断 B 是否有这一位        if(i &lt; B.size())             t -= B[i];                // 综合处理两种情况：1. t&gt;=0, 即t；2. t&lt;0, 借一位        C.push_back((t + 10) % 10);                // 判断是否需要借一位        if(t &lt; 0) t = 1;        else t = 0;    &#125;        // 去掉高位存在的0    while(C.size() &gt; 1 &amp;&amp; C.back() == 0)        C.pop_back();        return C;&#125;\n\n例题：792. 高精度减法\nA * b 型A &#x2F; b 型","categories":["数据结构与算法"],"tags":["数据结构","算法"]}]