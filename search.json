[{"title":"位运算","url":"/2023/11/01/algo/bitwise_operation/","content":"两个问题与一个补充\n\nx 的二进制表示中第 k 位是多少\n统计 x 二进制表示中 1 的个数\n原码、补码、反码\n\n\n\n模板模板1：n 的二进制表示中第 k 位是几\n从个位起，个位为第 0 位\n\n\n先把第 k 位移到最后一位（右移 k）\n看个位是几（与 1）\n\ncout &lt;&lt; (n &gt;&gt; k &amp; 1);\n\n\n\n模板2：lowbit(x)，统计x中1的个数lowbit(x)：返回 x 的最后一位 1 之后的二进制数（二进制，即最右边）\n\n例如：x &#x3D; 10100，lowbit(x) &#x3D; 100\n\n// 整数的负数是补码（~x+1 取反加一）// -x = ~x+1int lowbit(int x)&#123;    return x &amp; -x;&#125;// 从最低位开始循环消除最后一位1，同时统计消除的次数，即得到二进制x中1的个数x -= lowbit(x);\n\n例题：801. 二进制中1的个数\n知识点补充：原码、反码、补码原码：0...01010\n反码：1...10101\n补码：1...10110（~x+1）\n一种解释x + (-x) = 0-x = 0 - x   = 0...0 - x   = 10...0 - x（从更高位借1）   = ~x + 1\n\n","categories":["数据结构与算法"],"tags":["数据结构","算法"]},{"title":"二分法","url":"/2023/06/27/algo/bisection/","content":"\n二分的本质：在区间中找到满足某种性质的边界，使得区间二分为“不重叠”的两部分，每次选择答案所在的区间进行下一步处理，当区间长度为1时，即得到查找的答案（或可判断为无解）\n\n有单调性一定可以二分，没有单调性也可以二分（二分本质不是单调性）\n\n\n整数二分的两个模板\n两个模板的区别主要是看 mid 属于左边，还是右边，属于右边时 mid &#x3D; (r + l + 1) &#x2F; 2！\n\n\n\n模板一：mid 属于左区间区间[l, r]被划分成[l, mid]和[mid + 1, r]\nbool check(int x) &#123;/* ... */&#125; // 检查x是否满足某种性质int bsearch_1(int l, int r)&#123;    while (l &lt; r)    &#123;        int mid = l + r &gt;&gt; 1;\t\t// 找中间值 (l+r)/2                // check()判断 mid 是否满足性质        if (check(mid)) \t\t\t            r = mid;    \t// 满足（该情况下左区域包含 mid）        else             l = mid + 1;\t// 不满足（从 mid 下一个位置）    &#125;    return l;\t// 最后 l == r，跳出循环&#125;\n\n\n\n模板二：mid 属于右区间区间[l, r]被划分成[l, mid - 1]和[mid, r]\nbool check(int x) &#123;/* ... */&#125; // 检查x是否满足某种性质int bsearch_2(int l, int r)&#123;    while (l &lt; r)    &#123;        int mid = l + r + 1 &gt;&gt; 1;        // 补 +1，当 l = r-1 时，确保不会死循环（两个模板的主要区分点）                if (check(mid))             l = mid;        else             r = mid - 1;    &#125;    return l;&#125;\n\n\n\n整数二分重要思想\n有序数列，查找 — 选取二分法\n\n\n先写 check() 函数\n根据 check(mid) 判断 mid 的值在左 / 右区间，选取模板\n如果无解，记得满足题意\n\n例题：789. 数的范围\n浮点数二分\n浮点数二分不需要区分边界，每次都是严格取得中间值\n\n\n当最终区间范围足够小时，可认为取得最终答案\n\nbool check(double x) &#123;/* ... */&#125; // 检查x是否满足某种性质double bsearch_3(double l, double r)&#123;    const double eps = 1e-6;    // eps 表示精度，取决于题目对精度的要求    \t\t\t\t\t\t\t// 一般是题目要求的精度下探两位    while (r - l &gt; eps)\t\t\t// 也可以是循环 100 次    &#123;        double mid = (l + r) / 2;        if (check(mid))             r = mid;        else             l = mid;    &#125;    return l;&#125;\n\n\n\n例题4. 寻找两个正序数组的中位数暴力解法\n\n直接将第二个数组添加到第一个末尾 -&gt; 排序 -&gt; 求中位数 O(m+n)\n双指针合并两个数组 -&gt; 排序 -&gt; 求中位数O(m+n)\n\n参考解法\n\n参考题解：使用二分法切分两个数组，求中间的值\n\n参考模板链接\n","categories":["数据结构与算法"],"tags":["数据结构","算法"]},{"title":"面向算法的 Cpp 用法","url":"/2023/12/22/algo/cpp_for_algo/","content":"\n求解算法题需要用到的那些 Cpp 语法\n\n\n\nSTL 及常用类型vector 变长数组\n系统为某一程序分配空间时，所需时间与空间大小无关，而与申请的次数有关\n\n\n类似数组，但可以动态扩展（找更大的内存空间，将原数组拷贝，释放原空间）\n倍增思想\n\n头文件：#inlude &lt;vector&gt;\n定义方式vector&lt;T&gt; v;\t\t\t// 模板实现vector&lt;int&gt; a(10, 3);\t// 长度为10，元素都初始化为3vector&lt;int&gt; a[10];\t\t// vector数组，即10个vector\n\n使用// 判空和返回大小基本上STL都有v.empty();\t\t// 判空v.size();\t\t// 返回元素个数（时间复杂度为 O(1)）v.clear();\t\t// 清空v.push_back(elem);\t\t// 尾部插入元素 elemv.pop_back();\t\t\t// 删除最后一个元素v.front();\t// 返回容器第一个元素v.back();\t// 返回容器最后一个元素// 迭代器v.begin();\t// 第0个数v.end();\t// 最后一个数的后面一个数（v.[size()]）// 支持比较运算？\n\n使用技巧\n\n可以用”[下标]“操纵容器（支持随机寻址）\n在创建 vector 时如果没有指定长度，则 vector 中不存在任何元素，无法被读取\n仅当 vector 某位置已经存在元素时，才可以使用下标进行操作\n使用v.size()获取大小时，返回的类型为unsigned int\n\n遍历方式for(int i = 0; i &lt; v.size(); i++)     cout &lt;&lt; a[i] &lt;&lt; endl;for(vector&lt;int&gt;::iterator i = v.begin(); i != v.end(); i++)\t    cout &lt;&lt; *i &lt;&lt; endl;for(auto x : a)     cout &lt;&lt; x &lt;&lt; endl;\n\n？迭代器？指针？\nv.end()是什么类型、值？\n理解 resize() 和 reserve()\nhttps://blog.csdn.net/liuweiyuxiang/article/details/88692708\npair 存储二元组// 将两个数据组成一组数据pair&lt;T1, T2&gt; p;p.first;\t// 返回第一个元素p.second;\t// 返回第二个元素typedef pair&lt;T1, T2&gt; PII;\t// 简化声明// 初始化pair&lt;int, int&gt; p;p = &#123;1, 2&#125;;p = make_pair(3, 4);// 支持比较运算（按字典序？），first为第一关键字，second为第二关键字// 存多个值pair&lt;int, pair&lt;int&gt;&gt; p3;\n\n\n使用sort()进行排序时，首先以左端点进行排序，仍然相同的话再以右端点进行排序\n\nstring// 支持用 + 拼接string str = &quot;hello &quot;;str += &quot;cpp&quot;;\t// &quot;hello cpp&quot;str.size();\t\t// 返回元素个数str.length();\t// 同上str.empty();\t// 判空str.clear();\t// 清空str.substr(1, 2);\t// 从下标1开始，返回2个字母的子串（子串长度）// 第二个参数省略或超出索引范围，都会返回从1开始的所有子串str.a_str();\t// 返回str字符数组的起始地址\n\n\n\nqueue 队列头文件：#include &lt;queue&gt;\nqueue&lt;int&gt; q;q.size();q.empty();// 没有清空函数，清空：q = queue&lt;int&gt;();q.front();\t// 返回队头q.back();\t// 返回队尾q.push();\t// 入队q.pop();\t// 出队\n\n\n\npriority_queue 优先队列\n实现原理是堆，默认为大根堆\n\n头文件：#include &lt;queue&gt;\npriority_queue&lt;int&gt; heap;heap.push();heap.pop();heap.top();\t// 返回堆顶元素\n\n转化为小根堆方法1：存入时存的是负数\n方法2：\n// 定义小根堆priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; heap;\n\n\n\nstack 栈stack&lt;int&gt; stk;stk.push();stk.pop();stk.top();\t// 返回栈顶元素\n\n\n\ndeque 双端队列头文件：#include &lt;deque&gt;\ndeque&lt;int&gt; dq;dq.clear();dq.front();dq.back();dq.push_back();dq.push_front();\t// 从头插入dq.begin();dq.end();// 支持随机寻址dq[i];\n\n\n\nset，multiset头文件：#include &lt;set&gt;\n\nset没有重复元素\nmultiset没有重复元素\n\nset&lt;int&gt; s;multiset&lt;int&gt; ms;s.clear();s.insert(i);\t// 插入s.count();s.find(k);\t\t// 返回查找到 key=k 元素的迭代器（不存在，则返回end()）s.erase(x);\t\t// 删除所有x，k + logNs.erase(iterator);\t// 删除该迭代器s.lower_bound();\t// 返回大于等于x的最小的数的迭代器s.upper_bound();\t// 返回大于x的最小的数的迭代器\n\n\n\nmap，multimap头文件：#include &lt;map&gt;\nmap&lt;string, int&gt; a;a.insert(x);\t// x是一个paira.erase(x);\t\t// x是pair或迭代器a.find();// 可以像数组一样用 mapa[&quot;jk&quot;] = 1;\t// logN 而不是 O(1)a[&quot;jk&quot;]; \t\t// 查找a.lower_bound();\ta.upper_bound();\t\n\n迭代器++&#x2F;–：O(logN)\n哈希表\nunordered_set，unordered_map，unordered_multiset，unordered_mulimap\n\n记得引入头文件\n\n增删改查时间复杂度是O(1)\n（内部无序）不支持a.lower_bound() / a.upper_bound()\t\n不支持迭代器++/--\n\nbitset\n压位（省八位空间）\n\nbitset&lt;num&gt; s;\t// 定义长度为num的bitset// 支持所有位运算// []count();\t// 返回1的个数\n\n\n\n\n\n\n\n数据处理方法与技巧选择高效的读入方式\n经验：当输入比较多时，选择高效的读入方式\n\n选择printf/scanf，而非cout/cin\n当 C++ 读读取大量数据时，使用前者甚至可以提速十倍\n尤其是将cin替换为scanf，读取速度可以显著提高\n\n// printf 输出 用法printf(&quot;字符串&quot;);printf(&quot;格式控制符1 输出控制符2...&quot;，输出参数1，输出参数2,...);// 格式控制符，输出参数的个数一一对应printf(&quot;格式控制符 非输出控制符&quot;, 输出参数);// scanf 输入 用法scanf(&quot;格式控制符&quot;, &amp;输入参数);\t// 不要忘记&quot;&amp;&quot;\t// 变量前有 &amp; 表明“放到以变量的地址为地址的变量中”\n\n优化cout/cin// 在main函数内添加如下代码之一ios::sync_with_stdio(false);\t// code1cin.tie(0);\t// code2\n\n\n\n浮点数处理经验：保留 k 位小数，精度下探两位\n用法：使用cout输出，保留固定位数的小数\n/* 写法一 */#include &lt;iomanip&gt;\t// 需要使用的头文件cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(6) &lt;&lt; a &lt;&lt; endl;// 输出保留6位小数的变量a/* 写法二 */printf(&quot;%.6lf&quot;, a);\t\t// 更简洁\n\n// 使用scanf输入doublescanf(&quot;%lf&quot;, &amp;a);\t\n\n\n\n字符串处理字符串处理函数// substr() 字符串指定长度复制str.substr(pos, len)// 返回值 string，包含str中从pos开始的len个字符的拷贝// pos 的默认值为 0，len 的默认值为 s.size() - pos（默认拷贝整个字符串）\n\n语法题：左旋转字符串\n语法题：把字符串转换成整数\n经验：\n\n字符类型的0对应于 ASCII 码48，获得整数需要-&#39;0&#39;\n字符数组存储的元素是数字的判断语句\n\nstr[k] &gt;= &#39;0&#39; &amp;&amp; str[k] &lt;= &#39;9&#39;\n\n可以用1e11为界限判断int类型是否越界\n当结果可能超出范围时，选取更大的类型，并返回时进行强制转换\n\n字符串与字符数组字符串类型：\nhttps://blog.csdn.net/ksws0292756/article/details/79432329\n\nstring\nchar*：指向字符串首个字母的指针\nchar[]\n\n常用辅助函数和特殊值常用辅助函数#include &lt;algorithm&gt;\t// 算法头文件std::max(a, b);\t\t\t// 返回参数 a 和 b 的最大值std::min(a, b);\t\t\t// 返回参数 a 和 b 的最小值std::swap(a, b);\t\t// 交换参数 a 和 b 的值\n\n#include &lt;cmath&gt;\t// 头文件pow(4, 2);\t\t// 4 的平方sqrt(4);\t\t// 4 开方abs(b-a);\t\t// 绝对值reverse(first, last);\t// 反转 [first，last) 范围内元素的顺序vector&lt;int&gt; v = &#123;5,4,3,2,1&#125;;reverse(v.begin(), v.end());\t// v = &#123;1,2,3,4,5&#125;string str = &quot;www.mathor.top&quot;;reverse(str.begin(), str.end());\t// str = &quot;pot.rohtam.wwww&quot;// begin(), end() 函数，可用于 string，vector,...v.begin();\t// 返回指向首个元素的指针v.end();\t// 返回指向最后一个元素“之后位置”的指针\n\n\n\n特殊值最大最小值// 最大最小intint a = INT_MIN;int b = INT_MAX;\n\n\n\n\n\n\n\n等待补充puts&#x2F;gets vs cout&#x2F;cin\n参考","categories":["数据结构与算法"],"tags":["数据结构","算法","编程语言","C++"]},{"title":"高精度","url":"/2023/08/15/algo/high_accuracy/","content":"\nC++ 选手需要处理大整数运算\n\nC++ 存储大整数的方式：将每一位存储到数组中，下标0元素对应个位、1元素对应十位…，依次类推（高位存储在数组末端，方便在运算时进行进位操作）\n\n\n常用运算模板\n\nA + B 型（两大整数相加）：（位数）len(A) &lt;=  10^6，len(B) &lt;=  10^6\nA - B 型（两大整数相减）：len(A) &lt;=  10^6，len(B) &lt;=  10^6\nA * b 型（大整数乘小整数）：len(A) &lt;=  10^6，b &lt;= 10^9\nA &#x2F; b 型（大整数除小整数）\n\n从题中读入、输出大整数// 已知输入为两行，分别为大整数 A 和 B#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123;    // 大整数用字符串先读入    string a, b;    vector&lt;int&gt; A, B;        cin &gt;&gt; a &gt;&gt; b;        // 存入 vector（e.g. &quot;123456&quot; -&gt; [6,5,4,3,2,1]）    for(int i = a.size() - 1; i &gt;= 0; i--)        // 存数字，字符要减去偏移量&#x27;0&#x27;        A.push_back(a[i] - &#x27;0&#x27;);    for(int i = b.size() - 1; i &gt;= 0; i--)        B.push_back(b[i] - &#x27;0&#x27;);        // 进行操作    auto C = func(A, B);        // 读入和输出都是从最高位开始    for(int i = C.size() - 1; i &gt;= 0; i--)        printf(&quot;%d&quot;, C[i]);        return 0;&#125;\n\n\n\n\n\nA + B 型Ci = (Ai + Bi + ti)%10, ti = (Ai-1 + Bi-1)/10\n// C = A + B, A &gt;= 0, B &gt;= 0vector&lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123;    if(A.size() &lt; B.size())\treturn add(B, A);        vector&lt;int&gt; C;    int t = 0;    for(int i = 0; i &lt; A.size(); i++)    &#123;        // 加上进位，如果有B[i]也加上        t += A[i];        if(i &lt; B.size()) t += B[i];                // 取余为i位的值，保存进位t        C.push_back(t % 10);        t /= 10;    &#125;        if(t) C.push_back(t);        return C;&#125;\n\n例题：791.高精度加法\nA - B 型\n先判断 A 和 B 的大小，选择运算次序\n\n// 判断 A &gt;= B bool cmp(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123;    if(A.size() != B.size()) return A.size() &gt; B.size();        for(int i = A.size() - 1; i &gt;= 0; i--)        if(A[i] != B[i])            return A[i] &gt; B[i];        return true;\t// 包含A == B的情况&#125;// C = A - B, A &gt;= B, A &gt;= 0, B &gt;= 0vector&lt;int&gt; sub(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123;    vector&lt;int&gt; C;        // 已保证 A &gt;= B    for(int i = 0, t = 0; i &lt; A.size(); i++)    &#123;        // 减去上一位借位        t = A[i] - t;                // 判断 B 是否有这一位        if(i &lt; B.size())             t -= B[i];                // 精妙处理！：综合处理两种情况：1. t&gt;=0, 即t；2. t&lt;0, 借一位        C.push_back((t + 10) % 10);                // 判断是否需要借一位        if(t &lt; 0) t = 1;        else t = 0;    &#125;        // 去掉高位存在的0    while(C.size() &gt; 1 &amp;&amp; C.back() == 0)        C.pop_back();        return C;&#125;\n\n例题：792. 高精度减法\nA * b 型// C = A * b, A &gt;= 0, b &gt;= 0vector&lt;int&gt; mul(vector&lt;int&gt; &amp;A, int b)&#123;    vector&lt;int&gt; C;        int t = 0;        // &quot;||t&quot; 条件表示进位 t 还没处理完    for(int i = 0; i &lt; A.size() || t; i++)    &#123;        if(i &lt; A.size()) \t\t\t// 如果A还没处理完：t = 上一位的进位 + A[i]*b            t += A[i] * b;                // 每次只考虑取余得到的个位和进位（下一位的个位）        C.push_back(t % 10);        t /= 10;    &#125;        // 去掉高位存在的0    while(C.size() &gt; 1 &amp;&amp; C.back() == 0)        C.pop_back();        return C;&#125;\n\n例题：793. 高精度乘法\nA &#x2F; b 型// C = A / b 余 r, A &gt;= 0, b &gt; 0// 余数 r 用的是实参（答案可能要用到）vector&lt;int&gt; div(vector&lt;int&gt; &amp;A, int b, int &amp;r)&#123;    vecotr&lt;int&gt; C;    r = 0;        for(int i = A.size() - 1; i &gt;= 0; i--)    &#123;        // 按照除法的逻辑：上一位的余数补在A[i]的左边一位        r = r * 10 + A[i];                // 保存当前位，以及余数 r        C.push_back(r / b);        r %= b;    &#125;        // C的开头存储的是数字的高位，需要调转    reverse(C.begin(), C.end());        // 删掉高位的0    while(C.size() &gt; 1 &amp;&amp; C.back() == 0)        C.pop_back();    return C;&#125;\n\n例题：794. 高精度除法\n参考算法基础课模板\n算法基础课\n","categories":["数据结构与算法"],"tags":["数据结构","算法"]},{"title":"离散化 | 区间和并","url":"/2023/11/01/algo/discretization_and_margin/","content":"\n离散化：当值域跨度大，但值分布稀疏时，将用到的值的坐标映射到较小空间内使用\n区间和并：快速合并所有有交集的区间\n\n\n\n离散化离散化：当值域跨度大，但值分布稀疏时，将用到的值的坐标映射到较小空间内使用，这样只需对映射后的数据结构进行操作即可节省空间开销（把无限空间中的有限个体映射到有限的空间中去）\n基本步骤\n存储操作需要数据的坐标到数组a\n对数组进行去重\n通过原坐标值找到现在的坐标，并进行操作（二分）\n\n数组去重// “排序 + 去重”// 存储所有待离散化的值vector&lt;int&gt; alls;// 将所有值排序sort(alls.begin(), alls.end());// 去掉重复元素alls.erase(unique(alls.begin(), alls.end()), alls(end));// unique(begin, end): 将有序数组去重，将重复元素放在容器末端，返回去重后的尾端点// erase(begin, end): 删掉数组中的元素（删掉尾端点之后的重复元素）\n\n补充：unique()实现逻辑采用双指针算法，找出有序数组中所有满足以下条件之一：\n\n该数是第一个数\na[i] != a[i-1]\n\n即是要找的不同的数\nvector&lt;int&gt;::iterator unique(vector&lt;int&gt; &amp;a)&#123;    int j = 0;    for(int i = 0; i &lt; a.size(); i++)    \tif(!i || a[i] != a[i-1])            // 满足条件后，记录在数组前部分，同时移动指针j            a[j++] = a[i];        return a.begin() + j; &#125;\n\n\n\n题型示例例题1：802. 区间和\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;// n次插入，2m次查询(l,m)，数量级都是10^5const int N = 3e5 + 10;// 存放数据对(1.坐标、c；2.查询区间)typedef pair&lt;int, int&gt; PII;int n, m;// 存放坐标插入的值，和其前缀和数组int a[N], s[N];// 存储所有被访问到的坐标(离散化的值)vector&lt;int&gt; alls;// 存储插入和查询操作的数据vector&lt;PII&gt; add, query;// 将坐标x映射为离散化下标(求x离散化之后的结果)int find(int x)&#123;    int l = 0, r = alls.size() - 1;    while(l &lt; r)    &#123;        int mid = l + r &gt;&gt; 1;        if(alls[mid] &gt;= x)               r = mid;        else             l = mid + 1;    &#125;    return r + 1;&#125; int main()&#123;    cin &gt;&gt; n &gt;&gt; m;        for(int i = 0; i &lt; n; i++)    &#123;        int x, c;        cin &gt;&gt; x &gt;&gt; c;        add.push_back(&#123;x, c&#125;);  // 存放插入操作的数据对        alls.push_back(x);      // 存放插入用的的下标x    &#125;        for(int i = 0; i &lt; m; i++)    &#123;        int l, r;        cin &gt;&gt; l &gt;&gt; r;        query.push_back(&#123;l, r&#125;);    // 存放查询操作的数据对        alls.push_back(l);          // 存放查询用到的下标        alls.push_back(r);    &#125;        // 对alls离散化操作    // 1. 去重：排序 + 去重    sort(alls.begin(), alls.end());    alls.erase(unique(alls.begin(), alls.end()), alls.end());        // 2. 映射坐标，进行相应操作    for(auto item : add)    &#123;        int x = find(item.first);        a[x] += item.second;    &#125;        for(int i = 1; i &lt;= alls.size(); i++)        s[i] = s[i-1] + a[i];        for(auto item : query)    &#123;        int l = find(item.first), r = find(item.second);        cout &lt;&lt; s[r] - s[l-1] &lt;&lt; endl;    &#125;            return 0;&#125;\n\n\n\n例题2：759. 格子染色\n区间合并题型\n给定 n 个区间[li,ri]，要求合并所有有交集的区间\n\n注意如果在端点处相交，也算有交集（有公共端点）\n\n输出合并完成后的区间个数\n\n\n思路\n按区间左端点排序\n以左端点为基准，当前区间与之后的区间有三种情况\n\n\n例题：803. 区间合并\n// segs 存放所有区间的首、尾端点void merge(vector&lt;PII&gt; &amp;segs)&#123;    vector&lt;PII&gt; res;        // 按左端点进行排序    sort(segs.begin(), segs.end());        // 设定为最边界（范围边界*2）    int begin = -2e9, end = -2e9;    for(auto seg : segs)        // 1. 满足上图无交集的情况，且不是初始值时        if(end &lt; seg.first)        &#123;            if(begin != -2e9)                res.push_back(&#123;begin, end&#125;);\t// 保存答案            begin = seg.first, end = seg.second;\t// 更新当前区间        &#125;    \t// 2. 满足上图中①、②情况，更新为区间并集        else            end = max(end, seg.second);        // 保存最后begin-end维护的区间    if(begin != -2e9)        res.push_back(&#123;begin, end&#125;);            segs = res;&#125;\n\n\n\n参考算法基础课模板\n算法基础课\n","categories":["数据结构与算法"],"tags":["数据结构","算法"]},{"title":"KMP字符串匹配","url":"/2023/08/05/algo/kmp/","content":"\nKMP 是由 Knuth，Morris，Pratt 三人设计的线性时间字符串匹配算法\n\n\n\n模板题目链接：831.KMP字符串\n暴力解法for(int i = 1; i &lt;= n; i++)&#123;  bool flag = true; \tfor(int j = 1; j &lt;= m; j++)        // 看作 i + (j-1)    \tif(s[i+j-1] != p[j])    \t&#123;      \t\tflag = false;      \t\tbreak;    \t&#125;&#125;\n\n\n怎么理解i+j-1？\n\n使用 KMP 优化用到的概念s[]：模式串，即被匹配的字符串\np[]：模板串，用模板串去匹配模式串\n前缀：非平凡前缀，指除了最后一个字符外，一个字符串的全部头部组合\n后缀：非平凡后缀，指除了第一个字符外，一个字符串的全部尾部组合\n部分匹配值：前缀和后缀的最长共有元素的长度\nnext[]数组：部分匹配值表，存储每一个下标对应的部分匹配值\nnext[] 数组详解next[]数组是由对模板串（简称p串）预处理得到\n\nnext[j]表示p[1,j]的部分匹配值（p[1,j]串中前缀和后缀相同字符的最大长度）\n\nnext[j] = i，即p[1,i] = p[j - i + 1, j]\n\n\n\n求 next[] 数组过程：通过模板串自己与自己进行匹配得到（匹配过程类似KMP匹配）\n// 根据后缀定义，从第二个字符开始匹配for(int i = 2, j = 0; i &lt;= n; i++)\t&#123;  \twhile(j &amp;&amp; p[i] != p[j + 1])\t        j = ne[j];      // 下一个位置匹配成功，移动  \tif(p[i] == p[j+1])\t        j++;\t      // 当前长度的字符串匹配成功，记录已经匹配的长度（即前缀长度 = 后缀长度 = j）  \tne[i] = j;\t&#125;\n\n\n\nKMP匹配过程这里 s串和 p串都是从下标1开始\n\n匹配过程如上图所示：\n\n当s[a,b]与p[1,j]匹配，但下一个位置s[i] != p[j+1]时，要移动 p串\n区别于暴力解法，p 串并非向后移动1位，而是直接移动到下次能匹配该部分的位置（② 对应 ①）\n这种移动操作可由j = next[j]完成\n\n// KMP 匹配过程for(int i = 1, j = 0; i &lt;= m; i++)&#123;    while(j &amp;&amp; s[i] != p[j + 1])         j = ne[j];  \t// 1. j != 0 表示j没有退回起点，并非从头开始匹配  \t// 2. s[i] != p[j+1] 说明当前位置的下一个字符并不匹配  \t// j = ne[j] 调用next[j]，将模板串后移到后缀位置    \tif(s[i] == p[j + 1]) j++;  \t// 下一个位置匹配成功      if(j == n)\t// 整个模板串匹配成功    &#123;        printf(&quot;%d &quot;, i - n);\t// 匹配成功        j = ne[j];\t\t// 继续匹配下一个位置    &#125;&#125;\n\n\n\n完整代码#include &lt;iostream&gt;using namespace std;const int N = 1e5 + 10, M = 1e6 + 10;int n, m;char p[N], s[M];int ne[N];  // next数组（以防当作保留字报错）int main()&#123;    // 数组名+1，加上一个数组元素的字节数，即下标为1的元素的地址    // &quot;+1&quot;表示下标从1开始    cin &gt;&gt; n &gt;&gt; p + 1 &gt;&gt; m &gt;&gt; s + 1;\t        // 求next数组过程    for(int i = 2, j = 0; i &lt;= n; i++)    &#123;        while(j &amp;&amp; p[i] != p[j + 1])             j = ne[j];        if(p[i] == p[j + 1])             j++;        ne[i] = j;    &#125;        // kmp匹配过程     for(int i = 1, j = 0; i &lt;= m; i++)     &#123;         while(j &amp;&amp; s[i] != p[j + 1])              j = ne[j];         if(s[i] == p[j + 1])              j++;         if(j == n)         &#123;             printf(&quot;%d &quot;, i - n);             j = ne[j];              &#125;     &#125;     return 0;&#125;\n\n时间复杂度： O(N)\n参考题解：KMP 字符串\n算法基础课\n","categories":["数据结构与算法"],"tags":["数据结构","算法"]},{"title":"数组模拟：单双链表/栈/队列 | 单调栈/队列","url":"/2023/11/25/algo/linklist_stack_queue/","content":"\n数组模拟：链表（单链表、双链表）、栈、队列， 单调栈，单调队列\n\n\n\n数组模拟链表\n不使用动态链表（指针+结构体），因为 new 链表很慢（考虑效率）\n\n\n笔试常用的是使用数组模拟链表\n\n单链表\n常用于邻接表（存储树、图）\n\n\n采用静态链表的方式，数组表示链表\n\ne[N]存放数组的值，ne[N]表示next指针\n\n\n\n\nhead表示头结点的下标（指向链表第一个元素）\ne[i]表示节点i的值\nne[i]表示节点i的next指针是多少\n空节点下标指向-1\nidx存储当前已经用到了哪个点\n\nint head, e[N], ne[N], idx;// 初始化void init()&#123;    head = -1;    idx = 0;    // 都没用到，指向头结点&#125;// 头插法void add_to_head(int x)&#123;    ne[idx] = head;    head = idx;    e[idx] = x;    idx++;&#125;// 插入到第k个结点之后void add(int k, int x)&#123;    e[idx] = x;    ne[idx] = ne[k];    ne[k] = idx;    idx++;&#125;// 删掉第k个结点后面的结点void remove(int k)&#123;    ne[k] = ne[ne[k]];&#125;\n\n例题：826. 实现单链表\n双链表\n用来优化某些问题\n\n 省略定义头、尾结点，用下标 0 表示头 head，下标 1 表示尾 tail\n\ne[i]表示结点的值\nl[i]表示i前驱结点\nr[i]表示i后继结点\nidx 存储当前已经用到了哪个结点\n\nint e[N], l[N], r[N], idx;// 初始化void init()&#123;    // 0表示左端点，1表示右端点    // 初始情况：    r[0] = 1, l[1] = 0;        // 前两个已经被占用了    idx = 2;&#125;// 在第k个点右插xvoid add(int k, int x)&#123;    r[idx] = r[k], l[idx] = k;    l[r[k]] = idx;    r[k] = idx;    e[idx] = x;    idx++;&#125;// 删除第k个点void remove_k(int k)&#123;    r[l[k]] = r[k], l[r[k]] = l[k];&#125;\n\n例题：827. 双链表\n\n栈：后进先出，队列：先进先出\n\n数组模拟栈int stk[N], tt;\t// tt 表示栈顶下标// 插入stk[++tt] = x;// 删除tt--;// 判空if(tt &gt; 0)\t// not emptyelse\t\t// empty// 得到栈顶元素stk[tt];\n\n\n\n单调栈\n常见题型：给定序列，求序列中每一个数左边（或右边）离他最近（或满足其他条件）的数\n\n例题： 单调栈（左侧最近最小）\n问题：求序列中每一个数左边离它最近，且小于它的数 \n\n先想暴力做法，再通过性质优化\n\n\n思考暴力解法：双循环枚举（时间复杂度O(N^2)，直接超时）\n\n#include &lt;iostream&gt;using namespace std;const int N = 1e5 + 10;// 双循环枚举暴力解法int n, a[N];int main(void)&#123;    cin &gt;&gt; n;    for(int i = 0; i &lt; n; i++)        cin &gt;&gt; a[i];        for(int i = 0; i &lt; n; i++)    &#123;        bool flag = false;        // 枚举每个数左边的数        for(int j = i - 1; j &gt;= 0; j--)\t            if(a[j] &lt; a[i])            &#123;                cout &lt;&lt; a[j] &lt;&lt; &quot; &quot;;                flag = true;                break;            &#125;        if(!flag) cout &lt;&lt; -1 &lt;&lt; &quot; &quot;;    &#125;    return 0;&#125;\n\n\n思考单调栈：在遍历数组的同时，用栈存储当前位置左侧的元素\n\n规则：当前为a[i]，对于栈顶元素a[tt]构成逆序时（即 tt &lt; i 且 a[tt] &gt;= a[i]），则弹出栈顶直至栈顶小于a[i]\n\n按照这种方式入栈，得到的是单调栈，且栈顶即是a[i]满足题意条件的数\n\n思路：a[i]左侧的逆序数将永远不会被当做答案（a[i]用不到，对于a[i]右侧的数，a[i]显然是更好的选择）\n\n时间复杂度：每个元素x最多只会进栈和出栈一次，最多2N，即时间复杂度为O(N)\n\n#include &lt;iostream&gt;using namespace std;const int N = 1e5 + 10;int n, tt, stk[N];int main(void)&#123;    scanf(&quot;%d&quot;, &amp;n);\t    for(int i = 0; i &lt; n; i++)    &#123;        int x;        // 使用 scanf 而非 cin，优化读入速度        scanf(&quot;%d&quot;, &amp;x);                // 栈非空，且栈顶大于当前数 -&gt; 弹出（永远不会被用到）        while(tt &amp;&amp; stk[tt] &gt;= x)             tt--;        // 栈非空，则栈顶即是“x 左边最近、小于它的数”        if(tt)            cout &lt;&lt; stk[tt] &lt;&lt; &quot; &quot;;        // 否则，没有这样的数        else             cout &lt;&lt; -1 &lt;&lt; &quot; &quot;;                // 当前值入栈        stk[++tt] = x;    &#125;  \t    return 0;&#125;\n\n\n\n\n\n数组模拟队列// 队头 hh，队尾 tt（初始化指向-1，也可以指向0）int q[N], hh, tt = -1;\t// 队尾插入q[++tt] = x;// 队头弹出hh++;// 判空if(hh &lt;= tt)\t// not emptyelse\t\t\t// empty    // 取出队头元素q[hh]\n\n\n\n单调队列（后续二刷理解）\n常见题型：滑动窗口求最值，输出每次滑动窗口移动后的最大最小值  \n\n例题：154. 滑动窗口\n暴力做法：用队列维护窗口，遍历得到最值O(nk) （k 是窗口的大小）\n\n每次移动窗口：1. 新元素插入队尾；2. 从队头弹出元素\n\n单调队列优化：考虑队列中“没用”的元素\n\n如果存在逆序关系，则先进队列的元素一定不是最小值（序小值大）\n对于得到的单调队列，队头即是最小元素\n\n#include &lt;iostream&gt;using namespace std;const int N = 1e6 + 10;int n, k;int a[N], q[N];int main(void)&#123;    scanf(&quot;%d%d&quot;, &amp;n, &amp;k);    for(int i = 0; i &lt; n; i++)\t        scanf(&quot;%d&quot;, &amp;a[i]);        // 默认队尾指针指向 -1    int hh = 0, tt = -1;        for(int i = 0; i &lt; n; i++)    &#123;        // 这里队列存储的是数组a的下标    \t// 判断队头是否已经滑出窗口：        // 1. 判空 2. 判断队头是否滑出窗口（i-k+1表示窗口的第一个元素）        if(hh &lt;= tt &amp;&amp; i - k + 1 &gt; q[hh])            hh++;\t// ?                // 弹出队列中“不小于”当前值的元素        while(hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i])            tt--;                // 插入当前值        q[++tt] = i;        if(i &gt;= k - 1)             cout &lt;&lt; a[q[hh]] &lt;&lt; &quot; &quot;;    &#125;        puts(&quot;&quot;);        hh = 0, tt = -1;        for(int i = 0; i &lt; n; i++)    &#123;        if(hh &lt;= tt &amp;&amp; i - k + 1 &gt; q[hh])            hh++;        while(hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i])            tt--;        q[++tt] = i;        if(i &gt;= k - 1)             cout &lt;&lt; a[q[hh]] &lt;&lt; &quot; &quot;;    &#125;        puts(&quot;&quot;);        return 0;&#125;\n\n","categories":["数据结构与算法"],"tags":["数据结构","算法"]},{"title":"前缀和 | 差分","url":"/2023/08/20/algo/prefix_sum_and_difference/","content":"前缀和一维前缀和\n用法：快速求原数组中的一段数的和，时间复杂度：O(1)（不需要使用循环 O(N)）\n\n\n\n一维前缀和定义：\n原数组：a1, a2, a3, ..., an（数组下标从1开始！）\n前缀和数组：S1, S2, S3, ..., Sn，其中Si = a1 + a2 + ... + ai（下标也是从1开始，定义S0 = 0）\n求 Si\nfor(int i = 1; i &lt;= n; i++)\tSi = Si-1 + ai;\n求[l, r]这一段数的和：sum = Sr - Sl-1\t\t\n\n消除边界情况的差异，一般使前缀和从 1 开始，而数组也从下标 1 开始\n\n// 模板：求数组 a 中从 l 到 r 的和int a[N];int s[N];// 数组 s 和 a 都是从下标 1 开始存放元素，即 1~n 存放元素for(int i = 1; i &lt;= n; i++)\t    s[i] - s[i-1] = a[i];\t// 前缀和初始化sum = s[r] - s[l-1];\t\t// 区间和的计算\n\n例题：795. 前缀和\n二维前缀和\n用法：快速求出区域矩阵内的元素和\n\n求 Sij\n（方框内的点表示元素） \nfor(int i = 1; i &lt; n; i++)    for(int j = 1; j &lt; m; j++)        s[i][j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1] + a[i][j];\n\n\n\n求区域和：\n\n即整个区域减去两个矩形区域，再补上重复减去的区域\n\n​\t\nsum = s[x2][y2] - s[x2][y1-1] - s[x1-1][y2] + s[x1-1][y1-1];\n\n// 模板：求(x1, y1)和(x2, y2)区域内元素的和int a[N][N];int s[N][N];// 数组 s 和 a 都是从下标 1 开始存放元素，即 1~n 存放元素// 二维前缀和初始化for(int i = 1; i &lt;= n; i++)    for(int j = 1; j &lt;= m; j++)        s[i][j] = s[i][j-1] + s[i-1][j] - s[i-1][j-1] + a[i][j];// 求区域元素和sum = s[x2][y2] - s[x1-1][y2] - s[x2][y1-1] + s[x1-1][y1-1];\n\n\n\n例题：796. 子矩阵的和\n差分\n差分是前缀和的逆运算\n\n一维差分定义和用法差分定义\n\n这里的a、b数组都是从下标1开始\n\n\n原数组：a1, a2, a3, ..., an\n\n构造：b1, b2, b3, ..., bn\n\n使得：ai = b1 + b2 + b3 + ... + bi\n\n\n\n则 a 是 b 的前缀和，b 是 a 的差分\n\n用法：给区间[l, r]中的每个数加上c，求加后序列，使得时间复杂度 O(1)（无需遍历）\t\n\n已知数组b[n]，求新的数组a[1], ..., a[l]+c, a[l+1]+c, ...a[r]+c, a[r+1], ...,a[n]\n\n方法：只需修改：b[l]+c和b[r+1]-c即可求和\n\n\n修改b[l]为b[l]+c：使得a数组变为a[1], ..., a[l]+c, a[l+1]+c, ..., a[n]+c\n修改b[r+1]为b[r+1]-c：使得a数组从a[r+1]开始删掉加上的c\n\n// 差分的插入操作void insert(int l, int r, int c)&#123;    b[l] += c;\t\t    b[r + 1] -= c;&#125;\n\n构造差分数组// 方法一：根据定义进行构造// b[1] = a[1] - a[0] (a[0] == 0)// b[2] = a[2] - s[1]// ...for(int i = 1; i &lt;= n; i++)\tb[i] = a[i] - a[i-1];\n\n// 方法二：利用差分数组的插入操作直接进行构造for(int i = 1; i &lt;= n; i++)    insert(i, i, a[i]);\t// 函数定义在下面// 理解：相当于直接将初始数组转换为其差分数组// 即在[1,1]插入a[1]，在[2,2]插入a[2]，...b[1] = a[1], b[2] = -a[1];b[2] = a[2] - a[1], b[3] = -a[2];...b[i] = a[i] - a[i-1], b[i+1] = -a[i];...b[n] = a[n] - a[n-1], b[n+1] = -a[n];\t// 成功构造出差分数组 b\n\n模板// 1. 定义插入操作void insert(int l, int r, int c)&#123;    b[l] += c;\t\t    b[r + 1] -= c;&#125;// 2. 构造差分数组int b[N];for(int i = 1; i &lt;= n; i++)    insert(i, i, a[i]);// 3. 进行插入操作insert(l, r, c);// 4. 得到改变后的序列，即数组b的前缀和数组，即是要求的新序列数组for(int i = 1; i &lt;= n; i++)    b[i] += b[i - 1];\n\n例题：797. 差分\n二维差分使用差分矩阵逆向二维前缀和，原矩阵a[i][j]，差分矩阵b[i][j]，原矩阵是差分矩阵的前缀和\n用法：给子矩阵的每个元素加上常数 c，输出更改后的矩阵（时间复杂度达到 O(1)）\n\n\n修改b[x1][y1]+c，使得b[x1][y1]到b[xn][yn]都加上c\n修改b[x1][y2+1]-c、b[x2+1][y1]-c，使内部蓝色矩形以外的减去c\n修改b[x2+1][y2+1]+c，使红色矩阵补上额外减去的c\n\n// 差分矩阵的插入操作insert(int x1, int y1, int x2, int y2, int c)&#123;    b[x1][y1] += c;    b[x1][y2+1] -= c;    b[x2+1][y1] -= c;    b[x2+1][y2+1] += c;&#125;\n\n构造差分矩阵// 类似构造差分数组的第二种方法for(int i = 1; i &lt;= n; i++)    for(int j = 1; j &lt;= n; j++)        insert(i, j, i, j, a[i][j]);\n\n例题：798.  差分矩阵\n追加练习leetcode: 238. 除自身以外数组的乘积\n\n利用前缀积*后缀积解决\n时间复杂度O(N)，额外空间复杂度O(1)题解\n\nleetcode: 560. 和为 K 的子数组\n\n利用前缀和 + 哈希\n\n参考算法基础课模板\n算法基础课\n差分题解\n差分矩阵题解\n","categories":["数据结构与算法"],"tags":["数据结构","算法"]},{"title":"Trie 树（字典树）","url":"/2023/08/10/algo/trie/","content":"\nTrie 树（字典树）是用来高效地存储和查找字符串集合的数据结构\n\n\n\n模板题目模板题目链接：835. Tire字符串统计\n【题目】维护一个字符串集合（仅包含小写英文字母），支持：\n\n题目一般会限制为小写英文字母&#x2F;大写英文字母&#x2F;数字…\n\n\n向集合中插入字符串\n询问一个字符串在集合中出现了几次\n\n图解 Trie 树\n#include &lt;iostream&gt;using namespace std;const int N = 1e5 + 10;// 存储Tire树每个点的子节点(最多是26个字母)是第几个节点，没有则为0int son[N][26];\t// 以当前点结尾的字符串的数量int cnt[N];\t// 当前插入的节点是第几个（为0时，既是根节点，又是空节点）int idx;\t// 存储字符串char str[N];\t// 插入一个字符串void insert(char *str)&#123;    int p = 0;    // 字符串结尾为&#x27;\\0&#x27;，可以用str[i]判断是否走到结尾    for (int i = 0; str[i]; i++)    &#123;        // 将字母映射成 0~25        int u = str[i] - &#x27;a&#x27;;\t                // 当结点不存在子节点u时，创建节点        if (!son[p][u])          \tson[p][u] = ++idx;        p = son[p][u];    &#125;    // 记录以该字母结尾的数量    cnt[p]++;&#125;// 查询字符串出现的次数int query(char *str)&#123;    int p = 0;    for (int i = 0; str[i]; i ++ )    &#123;        int u = str[i] - &#x27;a&#x27;;        // 不存在满足的子节点，说明没有该字符串        if (!son[p][u])         \t\treturn 0;        p = son[p][u];    &#125;    // 满足字符串顺序，返回之前记录的值    return cnt[p];&#125;int main(void)&#123;\tint n;  \tscanf(&quot;%d&quot;, &amp;n);  \twhile(n--)  \t&#123;    \tchar op[2];    \tscanf(&quot;%s%s&quot;, op, str);    \tif(op[0] == &#x27;I&#x27;)      \t\tinsert(str);    \telse      \t\tprintf(&quot;%d\\n&quot;, query(str));  \t&#125;  \treturn 0; &#125;\n\n对 idx 的理解\nidx相当于分配了一个son[idx]节点存储下标（类似单链表的idx）\nson[idx][u]记录该下标对应的子节点的下标\n当查询时，根据son[idx][u]即可按照插入的字符串顺序查找到字符串出现的次数\n\n补充例题：143. 最大异或对：Tire 树存储整数\n参考算法基础课\n理解 idx（评论是精髓）\n","categories":["数据结构与算法"],"tags":["数据结构","算法"]},{"title":"双指针","url":"/2023/09/10/algo/two_pointers/","content":"核心思想：使用双指针扫描两个（两部分）序列，将朴素算法（两层循环）O(N^2)优化到O(N)\n一般解题思路：先思考暴力解法，再向双指针的方向优化\n\n\n标准模板\n双指针指向两个序列（如归并）\n双指针指向一个序列（如快排）\n\n// 双指针通用模板for(i = 0, j = 0; i &lt; n; i++)\t// j 也可能从其他位置开始&#123;    // 每次移动 i 指针时，考虑更新 j 指针    while(j &lt; i &amp;&amp; check(i, j))        j++;        // 题目具体逻辑&#125;\n\n例题-思考过程题目：799. 最长连续不重复子序列\n// 思考过程// 朴素做法（暴力解法）：O(n^2)for(int i = 0; i &lt; n; i++)    for(int j = 0; j &lt; n; j++)        if(check(j, i))        \tres = max(res, i - j + 1);// 双指针算法// 以 i 指针遍历序列，区间[j,i]内的元素表示最大不重复子序列// 即以 i 为右边界，找“离 j 最远的 i”，就是最大不重复子序列// 当遇到重复时，更新 j = ifor(int i = 0, j = 0; i &lt; n; i++)&#123;    while(j &lt;= i &amp;&amp; check(j, i))\t        j++;    res = max(res, i - j + 1);&#125;\n\n// 处理重复元素的思路：空间换时间（数据不是很大时适用）#include &lt;iostream&gt;using namespace std;const int N = 1e5 + 10;int a[N], s[N];int n;int main(void)&#123;    cin &gt;&gt; n;    for(int i = 0; i &lt; n; i++)\tscanf(&quot;%d&quot;, &amp;a[i]);    int res = 1；\t        // 双指针：i 指针遍历数组，同时用 j 指针指向距离 i 最远的不重复子数组    for(int i = 0, j = 0; i &lt; n; i++)    &#123;        // 开辟数组 s，存放 i 位置数字 a[i] 出现的次数        s[a[i]]++;                // 当元素 a[i] 重复（j一定小于i，省略判断）        while(s[a[i]] &gt; 1)\t        &#123;             // j 从当前位置开始移动，同时删除从当前位置到与a[i]重复的位置之间的元素出现次数            // 直到区间[j,i]内不包含重复元素停止            s[a[j]]--;\t\t            j++;        &#125;                // 记录从 i 到 j 之间的最大距离，即最大不重复子数组的长度        res = max(res, i - j + 1);    &#125;        cout &lt;&lt; res &lt;&lt; endl;    return 0;&#125;\n\n题目：66. 两个链表的第一个公共结点\n\n双指针遍历双链表相同长度后相遇 思路题解\n\n题目补充LeetCode：无重复字符的最长子串\n\n同样是利用数组记录（处理）重复元素\n条件“英文字母、数字、符号和空格组成”表示ascii前128个，只需开大小为128的数组即可\n后续掌握哈希&#x2F;桶等精进算法\n\nLeetCode：移动零\n\n利用快慢指针解决问题\n快指针遍历整个数组\n慢指针指向 0 序列的第一个 0，该位置之前是维护好的非零序列\n\nLeetCode: 相交链表\n\n链表A长度a + c = m，链表B长度b + c = n\n双指针分别遍历双链表，遍历后从另一个链表头节点重新开始遍历\n最终双指针遍历长度a + c + b = b + c + a（有相交区域时），即此时指向相交节点\n\n参考算法基础课模板\n算法基础课\n","categories":["数据结构与算法"],"tags":["数据结构","算法"]},{"title":"个人赏番目录","url":"/2022/11/27/anime/my_rank/","content":"\n记录个人番剧阅览表\n\n\n\n本命作CLANNAD ～AFTER STORY~\nCLANNAD\n30天推番挑战分类排名","categories":["娱乐"],"tags":["Anime","Record"]},{"title":"寻找目标","url":"/2023/06/23/life_plan/new_beginning/","content":"叹当下：昨夜西风凋碧树，独上高楼，望尽天涯路。\n愿未来：衣带渐宽终不悔，为伊消得人憔悴。\n","categories":["生活"],"tags":["经历"]},{"title":"Hexo 常用操作","url":"/2022/01/23/tech/hexo_operation/","content":"\nHexo 常用命令 | 文章变量设置\n\n\n\n主题使用使用 keep 主题\n主题更新 &#x2F; 样式设置\nPicX 图床\n常用命令hexo new [postName]\t\t# 在 source/_posts 下新建文章hexo new page [pageName]\t\t# 在 source/pageName 下新建页面hexo d\t\t# 将 .deploy 目录部署到 GitHubhexo g\t\t# 生成静态页面至 public 目录hexo s\t\t# 开启预览访问端口（默认 port：4000），ctrl + c 关闭 serverhexo clean\t\t# 清除所有静态页面和缓存数据\n\n\n\nFront-matter# 文章变量设置示例（置于_posts下文章最上方）---title:\t文章标题\t\tdate: 2020-01-21 12:00:00tags:\t[tag1, tag2]categories: [文章分类]&#123;sricky:\t权重值&#125;\t\t# 文章置顶位置&#123;toc:\tfalse&#125;\t\t# 关闭文章目录---# 文章截取符&lt;!--more--&gt;\n","categories":["技术"],"tags":["Hexo"]},{"title":"快速排序 | 归并排序","url":"/2023/06/24/algo/sort/","content":"\n分治算法基本三部：1. 分成子问题；2. 递归处理子问题；3. 子问题合并\n\n快速排序和归并排序都是基于分治的思想\n\n\n快速排序算法思想\n基于分治的思想：\n\n\n确定分界点：左边界q[l]，中间值q[(l+r)/2]，右边界q[r]，也可以随机\n调整区间：通过 x 的值，划分区间（x 左边≤x，右边≥x）△\n递归：递归处理左、右区间\n\n\n\n// 快排模板void quick_sort(int q[], int l, int r)&#123;    if(l &gt;= r) return;\t   \t    int i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1];    while(i &lt; j)    &#123;        do i++; while(q[i] &lt; x);        do j--; while(q[j] &gt; x);        if(i &lt; j) swap(q[i], q[j]);\t    &#125;    quick_sort(q,l,j);    quick_sort(q,j+1,r);&#125;// 参考：https://www.acwing.com/activity/content/code/content/39784/\n\n细节剖析// 快排模板void quick_sort(int q[], int l, int r)&#123;    // 判断边界，只有一个数/没有数则直接返回，也可以写作 ”l == r“    if(l &gt;= r) return;\t   \t    // 分成子问题    int i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1];    while(i &lt; j)    &#123;        do i++; while(q[i] &lt; x);        do j--; while(q[j] &gt; x);        if(i &lt; j) swap(q[i], q[j]);\t// swap,交换两个数    &#125;        // 递归处理子问题    quick_sort(q, l, j);    quick_sort(q, j+1, r);        // 子问题合并（此处不需要）&#125;\n\n语法补充\nl + r &gt;&gt; 1\t当左侧为非负数时，相当于 (l + r) &#x2F; 2（为负奇数时，会有区别）\ndo i++; while(q[i] &lt; x); 就是一个 do-while 循环\ndo&#123;    i++;&#125;while(q[i] &lt; x);    // 等价写法\n\n思路理解\n\n确定枢轴 x（这里选择的是数组中间的值）\n设置两个指针i, j，分别从数组两侧向中间移动\n利用循环，使得q[l...i] &lt;= x 且 q[j...r] &gt;= x\n递归排列左右两部分\n\n子问题理解\nint i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1];// 由于后面使用的是 do-while 循环，先增减再操作，需要确保从左右端开始\n\n使用 do-while：保证先递增，使得循环可以继续进行\n使用 while 可能会死循环（例：q[i] 和 q[j] 都等于 x 时，i j 不会更新，外层 while 循环卡死）\ndo i++; while(q[i] &lt; x);\t// 使 q[l...i-1] &lt;= x，q[i] &gt;= x     do j--; while(q[j] &gt; x);// 使 q[j+1...r] &gt;= x，q[j] &lt;= x     if(i &lt; j) swap(q[i], q[j]);\t// 交换，使得 q[l...i] &lt;= x，q[j...r] &gt;= x/* 边界问题：如果上述 do-while 循环的条件为 ≥ 或 ≤ \t\t假设数组 q[l...r] 内元素全相等，\t \t则语句 do i++; while(q[i] &lt;= x); 会执行到 r + 1\t \t然后执行 a[i] &lt;= x 也成立，则会一直循环下去；\t \t最终报错：Meomory Limit Exceeded. */\n\n如何得到递减序列？while(i &lt; j)&#123;    do i++; while(q[i] &gt; x);\t    // 此处比较运算符更改一下，循环结果取得 q[i] &lt;= x    do j--; while(q[j] &lt; x);    if(i &lt; j) swap(q[i], q[j]);\t&#125;\n\n参考：acwing 算法基础课\n例题：785. 快速排序\n归并排序算法思想\n基于分治的思想\n\n\n确定分界点，取数组下标中间值\n\n递归排序 left，right\n\n归并，合二为一 △（O(N)）\n\n\n// 归并模板void merge_sort(int q[], int l, int r)&#123;    if (l &gt;= r) return;    int mid = l + r &gt;&gt; 1;\t    merge_sort(q, l, mid);    merge_sort(q, mid + 1, r);    int k = 0, i = l, j = mid + 1;    while (i &lt;= mid &amp;&amp; j &lt;= r)        if (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];        else tmp[k ++ ] = q[j ++ ];    while (i &lt;= mid) tmp[k ++ ] = q[i ++ ];    while (j &lt;= r) tmp[k ++ ] = q[j ++ ];    for (i = l, j = 0; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];&#125;// 参考：https://www.acwing.com/blog/content/277/\n\n细节理解void merge_sort(int q[], int l, int r)&#123;    if (l &gt;= r) return;    // 分治第一步：分成子问题    int mid = l + r &gt;&gt; 1;\t/// 划分，取得区间中点            // 第二步：递归处理子问题    merge_sort(q, l, mid);\t// 递归排序左右区间    merge_sort(q, mid + 1, r);    // 第三步：合并子问题    int k = 0, i = l, j = mid + 1;   \t// i 指向左半边起点，j 指向右半边起点        while (i &lt;= mid &amp;&amp; j &lt;= r)\t// 当左右区间都没有循环为空时        // 取小的存入数组        if (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];\t        else tmp[k ++ ] = q[j ++ ];    // 把剩余没有为空的半边的数接入数组    while (i &lt;= mid) tmp[k ++ ] = q[i ++ ];    while (j &lt;= r) tmp[k ++ ] = q[j ++ ];    // 将临时数组的序列存回 q 数组中    for (i = l, j = 0; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];&#125;\n\nfor (i = l, j = 0; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];\n使用两个控制变量？根据前面定义的int k = 0；，在每次递归中，临时数组都是从下标0位置开始存放数据，而对于数组q，在递归中需要排序的范围是l-r，所以这里需要两个控制变量来转存\n// 使用一个控制变量的写法void mergeSort(int q[], int l, int r)&#123;    if(l &gt;= r)  return;        int mid = l + r &gt;&gt; 1;        mergeSort(q, l, mid);    mergeSort(q, mid + 1, r);    // 区别1：在每次递归中，都从临时数组的 &quot;l&quot; 位置开始存放数据    int i = l, j = mid + 1, k = l;      while(i &lt;= mid &amp;&amp; j &lt;= r)&#123;        if(q[i] &lt;= q[j])\ttemp[k++] = q[i++];        else\ttemp[k++] = q[j++];    &#125;    while(i &lt;= mid)\ttemp[k++] = q[i++];    while(j &lt;= r)\ttemp[k++] = q[j++];        // 区别2：这样针对递归中的每个 q[l...r]，    // 都可以有对应的 temp[l...r]，只用一个控制变量    for(i = l; i &lt;= r; i++) q[i] = temp[i];     &#125;\n\n\n\n参考课程：acwing 算法基础课\n例题：787. 归并排序\t788. 逆序对的数量\n","categories":["数据结构与算法"],"tags":["数据结构","算法"]},{"title":"搞定操作系统","url":"/2023/12/23/cs/OS/","content":"参考博客：图解系统，阿秀：操作系统\n\n\n知识点大纲参考：图解系统\n硬件结构冯诺依曼模型\n内存\n\n中央处理器 CPU\n\n总线\n\n输入、输出设备\n\n\n问题记录\n零拷贝？\n\n","categories":["计算机基础"],"tags":["OS","基础","cs"]},{"title":"并查集","url":"/2023/12/10/algo/disjoint_set/","content":"并查集用来快速（近乎O(1)）处理：\n\n将两个集合合并（并）\n\n询问两个元素是否在一个集合当中（查）\n\n\n\n\n基础并查集基本原理：每个集合用一棵树来表示，树根的编号就是整个集合的编号\n\n每个节点存储它的父节点，p[x]表示x的父节点\n\n/* 解决问题 */// 问题1：如何判断树根（除了树根，p[x]都是存放的父节点）if(p[x] == x)    // 问题2：如何求 x 的集合编号（查询所在集合）while(p[x] != x)    x = p[x];\t// 最后得到树根的编号，即该集合的编号// 问题3：如何合并集合（将另一个集合作为该集合树根的一个子节点）// px是x的集合编号，py是y的集合编号p[y] = x;\t// 把y插入到x的根节点\n\n\n路径压缩 △：遍历根节点后，将所有路径上的节点的父节点设置为根节点\n按秩合并\n\n#include &lt;iostream&gt;using namespace std;const int N = 1e5 + 10;int p[N];// 返回x的祖宗节点 + 路径压缩（核心操作）int find(int x) &#123;    if(p[x] != x)        p[x] = find(p[x]);    return p[x];&#125;int main() &#123;    int n, m;    cin &gt;&gt; n &gt;&gt; m;        // 每个节点的父节点都指向自己（即每个节点都初始化为根节点）    for(int i = 0; i &lt; n; i++)        p[i] = i;            while(m--) &#123;        char op;        int a, b;        cin &gt;&gt; op &gt;&gt; a &gt;&gt; b;        // 合并操作        if(op == &#x27;M&#x27;)             // a集合的根节点的父亲指向b集合的根节点            p[find(a)] = find(b);        else             if(find(a) == find(b))                cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;            else                cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;       &#125;    return 0;&#125;\n\n例题：Acwing: 836. 合并集合\n变形扩展情况：维护一些额外信息（如：每个集合中元素个数）\n连通块：\n只需保证根节点的size是有意义的\n合并集合的同时\nsize(b) += size(a);p[a] = p[b];\n\n特判：a和b在同一个集合中时，不需要再次合并和更新size\n#include &lt;iostream&gt;using namespace std;const int N = 1e5 + 10;int n, m;int p[N], num[N];int find(int x) &#123;    if(p[x] != x)        p[x] = find(p[x]);    return p[x];&#125;int main() &#123;    cin &gt;&gt; n &gt;&gt; m;        for(int i = 0; i &lt; n; i++) &#123;        p[i] = i;        num[i] = 1;    &#125;        while(m--) &#123;        string op;        int a, b;        cin &gt;&gt; op;        if(op == &quot;C&quot;) &#123;            cin &gt;&gt; a &gt;&gt; b;            // 需要特判            if(find(a) == find(b))                continue;            // 记录被连通的根节点的集合数            num[find(b)] += num[find(a)];            p[find(a)] = find(b);        &#125;        else if(op == &quot;Q1&quot;) &#123;            cin &gt;&gt; a &gt;&gt; b;            if(find(a) == find(b))                puts(&quot;Yes&quot;);            else                 puts(&quot;No&quot;);        &#125;        else &#123;            cin &gt;&gt; a;            cout &lt;&lt; num[find(a)] &lt;&lt; endl;        &#125;    &#125;        return 0;&#125;\n\n例题：Acwing: 连通块中点的数量\n练习题：Acwing: 食物链\n维护每个节点到根节点的距离\n","categories":["数据结构与算法"],"tags":["数据结构","算法"]},{"title":"堆","url":"/2023/12/15/algo/heap/","content":"\n手写一个堆\n\n\n\n堆：（STL 堆也支持）\n\n插入一个数\n求集合中的最小值\n删除最小值\n删除任意一个元素\n修改任意一个元素\n\n堆是一颗完全二叉树\n性质：（小根堆）每个点小于等于左右儿子，根节点是最小元素\n对节点下标的性质\n堆的存储：用一维数组存储\n\n\nstl里的树是优先队列（priority queue）\n堆的基本操作：\ndown(x);\t// 节点向下调整// 和两个儿子比较，找最小值，和当前节点的值进行交换// 直到满足标准堆up(x);\t\t// 节点向上调整// 和父节点比较，如果更小，当前节点的值和父节点的值进行交换\n\n实现堆的常用操作size应该就是idx\n插入一个数：heap[++size] = x; up(x);（插入到最后一个节点，向上调整堆）logn\n求最小值：heap[1]o(1)\n删除堆顶（最小值）：最后一个元素覆盖堆顶元素，向下调整堆顶heap[1] = heap[size];\nsize--;\tdown(1);logn\n删除最后一个元素：size--;\n删除任意一个元素（第k个）：heap[k] = heap[size]; size--; down(k); up(k);\n(up 和 down 只会执行一个，另一个判断后不会执行，简化判断都写一下)\n修改任意一个元素：heap[k] = x; down(k); up(k);\nO(N) 的建堆方式：从 n/2down到1（2&#x2F;n 的高度是1，即倒数第二层节点），如果从根开始就是O(NlogN)\n\n例题：Acwing: 堆排序\n#include &lt;iostream&gt;using namespace std;const int N = 1e5 + 10;int n, m, num;int h[N];void down(int k) &#123;    int t = k;    if(k*2 &lt;= num &amp;&amp; h[k*2] &lt; h[t])        t = k * 2;    if(k*2 + 1 &lt;= num &amp;&amp; h[k*2 + 1] &lt; h[t])        t = k * 2 + 1;    // 加判断条件    if(t != k) &#123;        swap(h[t], h[k]);        down(t);    &#125;&#125;int main() &#123;    cin &gt;&gt; n &gt;&gt; m;    for(int i = 1; i &lt;= n; i++)        cin &gt;&gt; h[i];    num = n;        // O(N) 的建堆方式    for(int i = n/2; i; i--)        down(i);            while(m--) &#123;        cout &lt;&lt; h[1] &lt;&lt; &quot; &quot;;        h[1] = h[num];        num--;        down(1);    &#125;        return 0;&#125;\n\n也可以补充到排序部分，贴一个链接\n// up 操作void up(int u) &#123;    // u/2 &gt; 0    while(u/2 &amp;&amp; h[u/2] &gt; h[u]) &#123;        swap(h[u/2], h[u]);        u /= 2;    &#125;&#125;\n\n例题：Acwing: 模拟堆（带映射版堆）\n需要记录是第几个插入的点，更新堆的同时，要更新记录数组的内容（定义全新的交换操作）\n// 开两个额外的数组存第k个插入的数是什么void heap_swap(int i, int j) &#123;\tswap(ph[hp[i]], ph[hp[j]]);    swap(hp[i], hp[j]);    swap(h[i], h[j]);&#125;// 画个图理解\n\nstrcmp()\n代码链接：https://www.acwing.com/activity/content/code/content/45305/\n","categories":["数据结构与算法"],"tags":["数据结构","算法"]},{"title":"哈希表","url":"/2023/11/10/algo/hashmap/","content":"\n哈希表用于把一个庞大的数据结构（空间&#x2F;值域）映射到较小的空间&#x2F;值域（0-n），0-1e9 -&gt; 0-1e5\n（用较小的索引检索到较大值域内的值）\n\n\n\n\n存储结构\n开放寻址法\n拉链法\n\n\n字符串哈希方式\n\n（离散化是一种及其特殊的哈希方式，需要保序单调递增）\nAcwing: 模拟散列表\n冲突：可能会把若干个数映射为同一个数\n处理冲突：都比较常用\n\n开放寻址法\n拉链法：开一维数组存储所有的哈希值，\n\n\t哈希表是一种期望算法，链的长度视为长度，一般可近似为O(1)\n常用操作：1. 插入\t2. 查找（一般不涉及删除，删除可以开数组标记被删掉的元素，表示被删掉，但实际不删掉）\n// 映射：取模的数一般取一个质数（冲突概率小一点） // 求大于1e5的质数for(int i = 100000; ; i++) &#123;    bool flag = true;    for(int j = 2; j * j &lt;= i; j++)        if(i % j == 0) &#123;            flag = false;            break;        &#125;    if(flag) &#123;        cout &lt;&lt; i &lt;&lt; endl;        break;    &#125;&#125;// &gt;&gt; 100003，即选为模数\n\n\n\n// 拉链法#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;// 选取大于指定长度的最小质数const int N = 1e5 + 3;int h[N];           // 哈希槽int ne[N], e[N];    // 拉链的链表int idx;            // 当前用到的位置void insert(int x) &#123;    // x % N 余数可能是负数    // + N 变余数为正数    int k = (x % N + N) % N;        // 单链表插入操作    e[idx] = x;    ne[idx] = h[k];    h[k] = idx ++;&#125;bool find(int x) &#123;    int k = (x % N + N) % N;    for(int i = h[k]; i != -1; i = ne[i]) &#123;        if(e[i] == x)            return true;    &#125;    return false;&#125;int main() &#123;    int n;    cin &gt;&gt; n;        // 将槽清空（单链表空指针用-1表示）    memset(h, -1, sizeof h);        while(n--) &#123;        char op;        int x;        cin &gt;&gt; op &gt;&gt; x;        if(op == &#x27;I&#x27;) &#123;            insert(x);        &#125; else &#123;            if(find(x))                puts(&quot;Yes&quot;);            else                puts(&quot;No&quot;);        &#125;    &#125;        return 0;&#125;\n\n开放寻址法\n开到数组的2-3倍\n从第k个位置，找到下一个没有存放元素的位置，插入冲突的元素【插入】\n从第k个位置开始，遍历查找到指定值【查找】\n数组标记查找的值，伪删除【删除】\n\n// 开放寻址法#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;// 选取质数const int N = 200003;// 初始化为范围之外的值const int null = 0x3f3f3f3f;int h[N];// 不冲突，返回他的位置// 冲突，返回它应该存储的位置int find(int x) &#123;    int k = (x % N + N) % N;        while(h[k] != null &amp;&amp; h[k] != x) &#123;        k++;        // 超出哈希表范围，返回应该存储的位置（接在表的后面）        if(k == N)            k = 0;    &#125;        return k;&#125;int main() &#123;    int n;    cin &gt;&gt; n;        // 将哈希表初始化    // 按字节，int 4个字节，相当于0x3f3f3f3f（4个）    // 最大值设置：INT_MAX vs 0x3f3f3f3f    memset(h, 0x3f, sizeof h);        while(n--) &#123;         char op;        int x;        cin &gt;&gt; op &gt;&gt; x;        int k = find(x);        if(op == &#x27;I&#x27;)            h[k] = x;        else &#123;            if(h[k] != null)                puts(&quot;Yes&quot;);            else                puts(&quot;No&quot;);        &#125;    &#125;        return 0;&#125;\n\n\n\n字符串哈希\n字符串前缀哈希法\n\n\n\n\n预处理所有前缀的哈希\n定义哈希值：\n字符串看做P进制的数\n将字符串转化为一个数字\n\n\n\n\n\n把字符串映射为0 - Q-1的数\n\n不要把字母映射为0\n不考虑冲突的情况（经验：p&#x3D;131或p&#x3D;13331，q&#x3D;2^64）\n\n可以利用前缀的哈希，得到所有子串的哈希值\nh[R];\t// p^R-1 ... p^0h[L-1];\t// p^L-2 ... p^0// 对齐h[R] - h[L-1] * p^(R-L+1);\t// 一段字符串的哈希值\n\n用unsigned long long存储哈希值，溢出即是mod 2^64\n快速判断：字符串的两个子串是否相同O(1)\nAcwing: 字符串哈希\n#include &lt;iostream&gt;using namespace std;const int N = 1e5 + 10;const int P = 131;  // 经验：取131或13331// 设置 Q = 2^64typedef unsigned long long ULL;int n, m;char str[N];// h存放哈希值，p记录h[i]对应的最高位是p的几次幂ULL h[N], p[N];ULL get(int l, int r) &#123;    return h[r] - h[l - 1] * p[r - l + 1];&#125;int main() &#123;    int n, m;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; str + 1;        p[0] = 1;        for(int i = 1; i &lt;= n; i++) &#123;        p[i] = p[i - 1] * P;                h[i] = h[i - 1] * P + str[i];   // 需要保证str[i] != 0    &#125;        while(m--) &#123;        int l1, r1, l2, r2;        cin &gt;&gt; l1 &gt;&gt; r1 &gt;&gt; l2 &gt;&gt; r2;                if(get(l1, r1) == get(l2, r2))            puts(&quot;Yes&quot;);        else            puts(&quot;No&quot;);    &#125;        return 0;&#125;\n\n\n\nkmp唯一相对优势：kmp求循环节\n参考","categories":["数据结构与算法"],"tags":["数据结构","算法"]},{"title":"递归","url":"/2023/07/24/algo/recursion/","content":"\n\n206. 反转链表\n","categories":["数据结构与算法"],"tags":["数据结构","算法"]},{"title":"DFS | BFS","url":"/2023/12/08/algo/DFS_BFS/","content":"\n\n\n\nDFS 深度优先搜索基本性质\n优先向深度搜索，搜索到叶节点回溯，确定当前节点没有子节点，继续回溯\n（数据结构）用栈\n（空间）与高度成正比 O(h)\n不具有最短性\n重要概念：1. 回溯   2. 剪枝\n算法思路比较奇怪？对空间要求比较高？\n暴搜\n\n\n\n例题理解\n每个DFS都对应一棵搜索树，最重要考虑顺序\n\nAcwing: 排列数字（全排列）\n（每次只会存储一条路径，不需要把整个树写出来，属于递归思路的一种）\n\n回溯：注意恢复现场\n\n#include &lt;iostream&gt;using namespace std;const int N = 10;int n;int path[N];    // 存储当前层存储的数字bool st[N];     // 记录当前数字有没有被用到 state[i]void dfs(int u) &#123;    // 搜索到底，所有位置填满，输出结果，返回，开始回溯    if(u == n) &#123;        // 从第0层开始，即 u = 1，输出该条路径上存储的所有数字        for(int i = 0; i &lt; n; i++) &#123;            cout &lt;&lt; path[i] &lt;&lt; &quot; &quot;;    // 输出路径上的数字        &#125;           puts(&quot;&quot;);        return;    &#125;        // 没有搜索到底，存入数字到没用过的位置，状态标为用过    for(int i = 1; i &lt;= n; i++) &#123;        // 当前位置没有被用到        if(!st[i]) &#123;            // 记录当前第 u 层存的数字 i，和数字 i 被用过的状态            path[u] = i;            st[i] = true;            // 递归搜索下一层，搜索到叶节点，开始回溯            // u == 0/1/2.../n 时，对应着搜索到第 0/1/2.../n 层            dfs(u + 1);                         // 回溯：恢复现场            // 省略了一步恢复 path[u] = 0            st[i] = false;        &#125;    &#125;&#125;int main() &#123;    cin &gt;&gt; n;    // 从第 0 层开始深度搜索    dfs(0);    return 0;&#125;\n\n\n\nAcwing: n-皇后问题\n注意剪枝，提前判断当前节点继续深度搜索不合法，直接回溯\n\n\n任意两个皇后，不能在同行、同列、同对角线上\n\n对角线y = -x + b, 截距 b = y + x\n反对角线坐标y = x + b上，截距 b = y - x, 加偏移量保证非负即 b = y - x + n\n思路1：转化为全排列问题，根据条件剪枝\tO(N*N!)\n\n全排列的思想，逐行确定一个皇后的位置，到最后一行时返回\n类似于排列中在每行摆一个不同的数字\n\n#include &lt;iostream&gt;using namespace std;const int N = 10;int n;char res[N][N];    // 存储方案// 记录当前列、对角线、反对角线是否被用到bool col[N];    // 列 y = b，col[y]bool dg[N];     // 正对角线 y = x + b，dg[n + y - x]bool udg[N];    // 反对角线 y = -x + b, udg[x + y]void dfs(int u) &#123;    if(u == n) &#123;        for (int i = 0; i &lt; n; i++)            puts(res[i]);        puts(&quot;&quot;);        return;    &#125;        for (int i = 0; i &lt; n; i++) &#123;        // u是横坐标，i是纵坐标，定值&quot;b&quot;对应一条对角线        // 相同坐标系对角线上不能有两个皇后        // 满足条件的继续递归，否则直接下一次循环        if(!col[i] &amp;&amp; !dg[u + i] &amp;&amp; !udg[n - u + i]) &#123;            res[u][i] = &#x27;Q&#x27;;            col[i] = dg[u + i] = udg[n - u + i] = true;            dfs(u + 1);            col[i] = dg[u + i] = udg[n - u + i] = false;            res[u][i] = &#x27;.&#x27;;        &#125;    &#125;&#125;int main() &#123;    cin &gt;&gt; n;        // 所有位置初始化    for(int i = 0; i &lt; n; i++)        for(int j = 0; j &lt; n; j++)            res[i][j] = &#x27;.&#x27;;        dfs(0);        return 0;&#125;\n\n\n\n思路2：枚举每个位置，剪枝进行化简\tO(2^N^2)\t\n\n从(0, 0)枚举，每个位置分为”放皇后“和”不放皇后“两种路径\n每次搜索到第N行，即深度最大，返回可能的结果\n\n#include &lt;iostream&gt;using namespace std;const int N = 10;char res[N][N];int n;// 行、列、对角线、反对角线状态bool row[N], col[N], dg[N], udg[N];// 搜索的位置 (x,y)，当前已经有的皇后数 svoid dfs(int x, int y, int s) &#123;    // 枚举到最后一列，则转到下一行的第一列    if (y == n) &#123;        y = 0;          x++;    &#125;        // 枚举到最后一行，输出方案结果    if (x == n) &#123;        // 已摆够皇后数        if(s == n) &#123;            for (int i = 0; i &lt; n; i++)                 puts(res[i]);            puts(&quot;&quot;);        &#125;        return;    &#125;        // 不放皇后，枚举下一个位置    dfs(x, y + 1, s);        // 放皇后（通过判断条件进行剪枝）    if (!row[x] &amp;&amp; !col[y] &amp;&amp; !dg[x + y] &amp;&amp; !udg[n - x + y]) &#123;        res[x][y] = &#x27;Q&#x27;;        row[x] = col[y] = dg[x + y] = udg[n - x + y] = true;        dfs(x, y + 1, s + 1);        // 回溯，恢复状态和值        row[x] = col[y] = dg[x + y] = udg[n - x + y] = false;        res[x][y] = &#x27;.&#x27;;    &#125;&#125;int main() &#123;    cin &gt;&gt; n;    for (int i = 0; i &lt; n; i++)        for (int j = 0; j &lt; n; j++)            res[i][j] = &#x27;.&#x27;;        dfs(0, 0, 0);    return 0;&#125;\n\n\n\n\n\nBFS 宽度优先搜索\n每次搜索先搜索本层的所有节点，之后再搜索下一层，每次只扩展一层\n用队列\n（空间）O(2^h)\n（以二叉树为例，二叉树第h层是2^h - 1个节点，第n层有2^n个节点）（复习一下）\n\n\n有最短路的性质（最小步数、最短距离、最少操作次数）【优势】\n\n\n\n\n搜到的是最短路\n\n\n\n（左下角节点搜索结果为第二层，权重为2，即存在最短路特性）\n\n只有当所有边的权重相同时，才能用BFS求最短路径\n\n","categories":["数据结构与算法"],"tags":["数据结构","算法"]},{"url":"/2024/03/04/algo/golang_for_algo/","content":"// 将切片赋值给数组// slice a// array bcopy(b, a)\t// 底层原理？// 类似 vector中 b.assign(a.begin(), b.end()); 用法\n\n"},{"title":"MySQL 常用操作","url":"/2024/02/01/cs/basic_mysql/","content":"\n使用 MySQL 的常用命令和部分知识点补充\n\n\n\n命令行使用MySQL# 使用密码在命令行登录 MySQL&gt; mysql -u root -p# ;结尾# 获得帮助mysql&gt; help mysql&gt; \\h# 退出命令行mysql&gt; quitmysql&gt; exit# control + d\n\n\n\nMySQL 命令\n书写习惯：\n\nSHOW 查看&#x2F;显示-- 查看数据库列表SHOW DATABASES;\t-- 使用数据库 database_nameUSE database_name;\t-- 查看数据库中表的列表SHOW TABLES;\t-- 查看表各列结构SHOW COLUMNS FROM table_name;\t-- 显示授权用户SHOW GRANTS;\t-- 显示服务器错误SHOW ERRORS;\t -- 显示警告信息SHOW WARNINGS;\t\n\nCREATE 创建表-- 可以使用反引号``将表名括起来，防止与MySQL关键字冲突CREATE TABLE tab_name (   col1 \tcol1_type \tNOT NULL,   col2 \tINTEGER \tAUTOINCREMENT,   col3 \tcol3_type \tNOT NULL\tDEFAULT 0,   .....   colN \tcolN_type,   PRIMARY KEY (col1)\t# 指定主键) ENGINE=InnoDB;/* 常用类型：TEXT 字符串, CHAR(100) 固长字符串INTEGER 整型, BIGINT 长整型, REAL 实数, BOOL 布尔值BLOB 二进制DATETIME 时间 */-- PRIMARY KEY 标记主键，NOT NULL标记非空-- AUTOINCREMENT 自增，只能用于整型-- DEFAULT 设置列默认值-- ENGINE=InnoDB 指定表使用的引擎\n\nDROP&#x2F;ALTER 删除&#x2F;更新表-- 删除表DROP TABLE tab_name;-- 新增列ALTER TABLE ADD COLUMNS col_name col_type;-- 重命名表ALTER TABLE old_tab RENAME TO new_tab-- 重命名列名ALTER TABLE tab_name RENAME COLUMN old_col TO new_col\n\nINSERT 新增记录-- 单条INSERT INTO tab_name VALUES (xx, xx)-- 指定列名（推荐）INSERT INTO tab_name (col1, col3) VALUES (xx, xx)-- 多条INSERT INTO tab_name (col1, col2, col3) VALUES    (xx, xx, xx),    ...    (xx, xx, xx);\n\nDELETE&#x2F;UPDATE 删除&#x2F;更新记录-- 删除满足条件的记录DELETE FROM tab_name WHERE [ condition ];-- 更新记录UPDATE tab_name SET col1=value1, col2=value2-- 更新满足条件的记录（推荐加上 WHERE）UPDATE tab_name    SET col1=value1, col2=value2    WHERE [ conditions ]\n\nSELECT 查询-- 所有列，通配符*SELECT * FROM tab_name;-- DISTINCT 去除重复 SELECT DISTINCT col1 FROM tab_name;-- COUNT() 统计个数 SELECT COUNT(*) FROM tab_name-- 指定列，逗号分隔SELECT col1, col2 FROM table_name;-- 带查询条件 &gt;，&lt;，&lt;&gt;，!=，=，&lt;=，&gt;=，BETWEEN AND-- 操作符 AND，OR，IN，NOTSELECT * FROM table_name \tWHERE col2 &gt;= 18 AND col1 &lt;&gt; 3;-- 空值判断 IS NULLSELECT column_name FROM table_name    WHERE column_name IS NULL;-- LIKE + 通配符（% 匹配字符串，_ 匹配单个字符）SELECT * FROM table_name    WHERE col2 &gt;= 18 AND col1 LIKE %stu%;    -- LIMIT 限制数量 SELECT * FROM table_name \tLIMIT 1;SELECT * FROM table_name \tLIMIT 4 OFFSET 3;\t# 从下标为3行开始，取4行\t-- GROUP BY 分组SELECT col1, count(*) FROM tab_name    WHERE [ conditions ]    GROUP BY col1    -- Having 过滤SELECT col1, count(*) FROM tab_name    WHERE [ conditions ]    GROUP BY col1    HAVING [ conditions ]    -- ORDER BY 排序, DESC 降序，ASC 升序，MySQL中&#x27;A&#x27;和&#x27;a&#x27;相同等级SELECT * FROM table_name \tORDER BY col2 DESC;\t-- SELECT 子句顺序：SELECT - FROM - WHERE - GROUP BY - HAVING - ORDER BY - LIMIT\n\n其他-- AS 别名SELECT col1 AS c1, col2 AS c2\tFROM table_name AS t;\t-- 内联结，或使用 WHERE 方式内联结SELECT col1, col2\tFROM table1 INNER JOIN tabel2;\n\nTransaction 事务-- 提交BEGIN;INSERT INTO ......COMMIT; -- 回滚BEGIN;...ROLLBACK;\n\n\n\n基本概念名词SQL 结构化查询语言（Structured Query Language）\nDBMS 数据库管理系统（数据库软件）\nschema 模式，关于数据库和表的布局及特性的信息\ncolumn 列，表中的一个字段\nrow 行，数据按行存储\nprimary key 主键，表中的一列或几列，唯一区分表中的每行，不同行主键不同，不允许NULL\n* 通配符\ntable_name.column_name 完全限定表名\nACID 事务具有原子性（Atomicity）、一致性（Consistency)、隔离性（Isolation）、持久性（Durability）四个标准属性\n其他补充MySQL 优点\n成本：开发源代码，可以免费使用\n性能：执行快\n可信赖\n简单：容易安装和使用\n\n默认端口：3306\n查看端口：SHOW GLOBAL VARIABLES LIKE &#39;port&#39;\n\n创建不同表可以指定不同的引擎\nInnoDB 提供事务处理，不支持全文本搜索\nMEMORY 数据存储在内存（不是磁盘），适合临时表\nMyISAM 高性能，支持全文本搜索，不支持事务处理\n注意：外键不能跨引擎\n\n","categories":["数据库"],"tags":["基础","cs","数据库"]}]